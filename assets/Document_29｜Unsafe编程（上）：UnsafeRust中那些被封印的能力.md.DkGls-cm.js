import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.D2WelYEY.js";const e="/tanggang_rust/assets/f71d96faf019a6e0dc3f4291cf251f88.DuE_JDot.jpg",o="/tanggang_rust/assets/4fd442ed26a7f5d05bdb32c9eca7f703.Ci-1kFFK.jpg",b=JSON.parse('{"title":"29 ｜ Unsafe 编程（上）： Unsafe Rust 中那些被封印的能力","description":"","frontmatter":{},"headers":[],"relativePath":"Document/29｜Unsafe编程（上）：UnsafeRust中那些被封印的能力.md","filePath":"Document/29｜Unsafe编程（上）：UnsafeRust中那些被封印的能力.md","lastUpdated":1740766764000}'),r={name:"Document/29｜Unsafe编程（上）：UnsafeRust中那些被封印的能力.md"};function t(c,s,B,i,y,u){return l(),a("div",null,s[0]||(s[0]=[p('<h1 id="_29-unsafe-编程-上-unsafe-rust-中那些被封印的能力" tabindex="-1">29 ｜ Unsafe 编程（上）： Unsafe Rust 中那些被封印的能力 <a class="header-anchor" href="#_29-unsafe-编程-上-unsafe-rust-中那些被封印的能力" aria-label="Permalink to &quot;29 ｜ Unsafe 编程（上）： Unsafe Rust 中那些被封印的能力&quot;">​</a></h1><p>你好，我是 Mike。</p><p>这门课目前已接近尾声，剩下的两节课我准备讲讲 Rust 中看起来有点黑魔法的部分——Unsafe Rust。这一节课我们先来聊聊相关的概念。</p><p>在前面课程的学习中，你有没有感觉到，Rust 编译器就像是一个严厉的大师傅，或者一个贴心的小助手，在你身边陪你结对编程，你写代码的时候，他盯着屏幕，时不时提醒你。如果某个时刻，这个大师傅或小助手突然离开了，你会不会慌？就像刚提车，第一次独自上路的那种感觉。</p><h2 id="三个王国" tabindex="-1">三个王国 <a class="header-anchor" href="#三个王国" aria-label="Permalink to &quot;三个王国&quot;">​</a></h2><p>Unsafe Rust 就是这样一个领域，进入这个领域，你突然拥有了几种必杀技能，但是身边已经没有大师傅同行了，只能靠你自己完全控制这几种技能的使用。使用得好，威力无穷。使用不好，对自己也会造成巨大伤害。Unsafe Rust 就是这样一个相对独立的领域。前面我们讲到过，Async Rust 也是相对独立的一个附属王国，现在又多了一个 Unsafe Rust 这样的附属王国。</p><p><img src="'+e+`" alt="图片"></p><p>Rust 语言可以看作是这三块疆域的合体，它们共同组成了一个联盟 Rust 王国。你甚至可以把 Rust 语言看成包含上面三种编程语言的一种混合语言。所以很多人抱怨 Rust 难学，也是可以理解的。</p><p>现在让我们把注意力集中在 Unsafe Rust 这个王国里面。它到底是什么样的？简单地说，你可以把它理解成这个王国里面住着一个 C 语言族的国王。也就是说，C 语言能做的事情，Unsafe Rust 都能做。C 语言能做哪些事情呢？理论上来说，它能做计算机中的任何事情。因此，在 Unsafe Rust 中，你也能做计算机中的任何事情。C 的强大威力来源于它锋利的指针，而在 Unsafe Rust 中也提供了这种能力。</p><h2 id="被封印的能力" tabindex="-1">被封印的能力 <a class="header-anchor" href="#被封印的能力" aria-label="Permalink to &quot;被封印的能力&quot;">​</a></h2><p>Safe Rust 王国有些技能被封印了，而这些技能进入到 Unsafe Rust 王国后，就可以被揭开使用。具体来说，有 5 种技能。</p><ol><li>解引用原始指针</li><li>调用 unsafe 函数或方法</li><li>访问或修改可变的静态变量</li><li>实现一个 unsafe trait</li><li>访问 union 中的字段</li></ol><p>这里我们简单提一下这 5 个方面，我们从第 5 点讲起。union 我们在课程里没有讲，这里我们简单了解下。它是一个类似于 C 中 union 的设计，也就是所有字段共同占有同一块存储空间。访问它的字段时，需要在 Unsafe Rust 中使用。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">union</span><span style="color:#E5C07B;"> IntOrFloat</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E06C75;">    i</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">    f</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">f32</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#C678DD;"> mut</span><span style="color:#E06C75;"> u</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> IntOrFloat</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">f</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">1.0</span><span style="color:#ABB2BF;"> };</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 读取union字段时需要用 unsafe {} 包起来</span></span>
<span class="line"><span style="color:#61AFEF;">assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">unsafe</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">u</span><span style="color:#ABB2BF;">.i }, </span><span style="color:#D19A66;">1065353216</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 更新了i，结果f字段的值也变化了。</span></span>
<span class="line"><span style="color:#E06C75;">u</span><span style="color:#ABB2BF;">.i </span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;"> 1073741824</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#61AFEF;">assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">unsafe</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">u</span><span style="color:#ABB2BF;">.f }, </span><span style="color:#D19A66;">2.0</span><span style="color:#ABB2BF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们一般用不到 union，如果需要深入研究，可以查看我给出的 <a href="https://doc.rust-lang.org/std/keyword.union.html" target="_blank" rel="noreferrer">链接</a>。</p><p>第 4 点，我们可以给 trait 实现 unsafe，这块内容比较深，所以在我们这门初级课程里不要求了解，如果你有兴趣可以查看我给出的 <a href="https://doc.rust-lang.org/nomicon/safe-unsafe-meaning.html" target="_blank" rel="noreferrer">链接</a>。</p><p>第 3 点也就是全局静态变量，前面我不提倡修改它，因为它是一种不太好的编程模型。但是如果你非要改的话，也是有办法的，那就留下足迹，加个 <code>unsafe {}</code> 套起来，比如 the book 里的 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable" target="_blank" rel="noreferrer">示例</a>。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 这里修饰为 mut</span></span>
<span class="line"><span style="color:#C678DD;">static</span><span style="color:#C678DD;"> mut</span><span style="color:#D19A66;"> COUNTER</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">u32</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> add_to_count</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">inc</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 修改全局可变静态变量需要用 unsafe</span></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#D19A66;">        COUNTER</span><span style="color:#56B6C2;"> +=</span><span style="color:#E06C75;"> inc</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#61AFEF;">    add_to_count</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 访问全局可变静态变量也需要用 unsafe</span></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">        println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;COUNTER: {}&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">COUNTER</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 输出</span></span>
<span class="line"><span style="color:#D19A66;">COUNTER</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>下面我来重点讲解一下前 2 种场景。</p><h3 id="unsafe-关键字" tabindex="-1">unsafe 关键字 <a class="header-anchor" href="#unsafe-关键字" aria-label="Permalink to &quot;unsafe 关键字&quot;">​</a></h3><p>Rust 中有一个 unsafe 关键字，用来显式地标明我们要进入 unsafe Rust 的领地。unsafe 关键字可以修饰 fn、trait，还可以在后面跟一个 {} 表明这是一个 unsafe 块，把可能不安全的逻辑包起来，像下面这样：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //...</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里，需要说明一下，被 unsafe 标识或包起来的代码，并不是说一定有问题。它的准确意思是： <strong>Rustc 编译器不保证被 unsafe 标识的代码是安全的，你应该保证你写的代码是安全的</strong>。</p><p>也就是说，unsafe 这个标识符，在代码中留下了明确的足迹，将交由 Rustc 全权保证安全的代码，和不交由 Rustc 全权保证安全的代码，分隔开了。</p><p>请注意上面这句话的用词，“不交由 Rustc 全权保证安全的代码部分”并不是说 Rustc 编译器就完全不检查 unsafe 里的代码了，实际 Rustc 只是对上面提到的 5 种技能不加检查。对于 Safe Rust 里的内容还是要做检查，跟之前一样。我们来看一个示例。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> v</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> [</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">        println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;COUNTER: {}&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">v</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">]);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 编译输出</span></span>
<span class="line"><span style="color:#E06C75;">warning</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">unnecessary</span><span style="color:#ABB2BF;"> \`</span><span style="color:#C678DD;">unsafe</span><span style="color:#ABB2BF;">\` </span><span style="color:#E06C75;">block</span></span>
<span class="line"><span style="color:#ABB2BF;"> --&gt; </span><span style="color:#E06C75;">src</span><span style="color:#ABB2BF;">/</span><span style="color:#E06C75;">main</span><span style="color:#ABB2BF;">.rs:</span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">5</span></span>
<span class="line"><span style="color:#56B6C2;">  |</span></span>
<span class="line"><span style="color:#D19A66;">4</span><span style="color:#56B6C2;"> |</span><span style="color:#C678DD;">     unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#56B6C2;">  |</span><span style="color:#56B6C2;">     ^^^^^^</span><span style="color:#E06C75;"> unnecessary</span><span style="color:#ABB2BF;"> \`</span><span style="color:#C678DD;">unsafe</span><span style="color:#ABB2BF;">\` </span><span style="color:#E06C75;">block</span></span>
<span class="line"><span style="color:#56B6C2;">  |</span></span>
<span class="line"><span style="color:#56B6C2;">  =</span><span style="color:#E06C75;"> note</span><span style="color:#ABB2BF;">: \`#[warn(unused_unsafe)]\` </span><span style="color:#E06C75;">on</span><span style="color:#E06C75;"> by</span><span style="color:#E06C75;"> default</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75;">error</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">this</span><span style="color:#E06C75;"> operation</span><span style="color:#E06C75;"> will</span><span style="color:#E06C75;"> panic</span><span style="color:#E06C75;"> at</span><span style="color:#E06C75;"> runtime</span></span>
<span class="line"><span style="color:#ABB2BF;"> --&gt; </span><span style="color:#E06C75;">src</span><span style="color:#ABB2BF;">/</span><span style="color:#E06C75;">main</span><span style="color:#ABB2BF;">.rs:</span><span style="color:#D19A66;">5</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">33</span></span>
<span class="line"><span style="color:#56B6C2;">  |</span></span>
<span class="line"><span style="color:#D19A66;">5</span><span style="color:#56B6C2;"> |</span><span style="color:#61AFEF;">         println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;COUNTER: {}&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">v</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">]);</span></span>
<span class="line"><span style="color:#56B6C2;">  |</span><span style="color:#56B6C2;">                                 ^^^^</span><span style="color:#E06C75;"> index</span><span style="color:#E06C75;"> out</span><span style="color:#E06C75;"> of</span><span style="color:#E06C75;"> bounds</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">the</span><span style="color:#E06C75;"> length</span><span style="color:#E06C75;"> is</span><span style="color:#D19A66;"> 3</span><span style="color:#E06C75;"> but</span><span style="color:#E06C75;"> the</span><span style="color:#E06C75;"> index</span><span style="color:#E06C75;"> is</span><span style="color:#D19A66;"> 3</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>示例中，我们需要重点关注 array 的下标索引越界的问题。我们在 <a href="https://time.geekbang.org/column/article/718865" target="_blank" rel="noreferrer">第 1 讲</a> 里已经讲过，array 的下标索引越界会在编译期被检查出来，可以看到，即使放在 unsafe block 中，它仍然执行了检查。这印证了我们上面的说法： <strong>被 unsafe 标识的代码，并不是让 Rustc 完全不管，而只是某几种技能让 Rustc 不管</strong>。Safe Rust 中的那些元素，Rustc 该管的还是要管。</p><p>所以即使是 Unsafe Rust，看上去也要比写 C 代码来得“安全”，犯错的风险更小一些。另外编译器指出这里 unsafe 块没什么用，可以去掉，我们确实没使用它。</p><h3 id="原始指针" tabindex="-1">原始指针 <a class="header-anchor" href="#原始指针" aria-label="Permalink to &quot;原始指针&quot;">​</a></h3><p>Rust 中有两种原始指针（raw pointer）， <code>*const T</code> 和 <code>*mut T</code>。用法如下：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> my_num</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">i32</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 10</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> my_num_ptr</span><span style="color:#ABB2BF;">: *</span><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> i32</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> &amp;</span><span style="color:#E06C75;">my_num</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#C678DD;"> mut</span><span style="color:#E06C75;"> my_speed</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">i32</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 88</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> my_speed_ptr</span><span style="color:#ABB2BF;">: *</span><span style="color:#C678DD;">mut</span><span style="color:#E5C07B;"> i32</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> &amp;</span><span style="color:#C678DD;">mut</span><span style="color:#E06C75;"> my_speed</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">        println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;my_num is: {}&quot;</span><span style="color:#ABB2BF;">, *</span><span style="color:#E06C75;">my_num_ptr</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">        println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;my_speed is: {}&quot;</span><span style="color:#ABB2BF;">, *</span><span style="color:#E06C75;">my_speed_ptr</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 输出</span></span>
<span class="line"><span style="color:#E06C75;">my_num</span><span style="color:#E06C75;"> is</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">10</span></span>
<span class="line"><span style="color:#E06C75;">my_speed</span><span style="color:#E06C75;"> is</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">88</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>也就是可以将不可变引用 <code>&amp;T</code> 转换成 <code>*const T</code> 指针。将可变引用 <code>&amp;mut T</code> 转换成 <code>*mut T</code> 指针。你也可以用 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer" target="_blank" rel="noreferrer">as 操作符</a> 来转换。</p><p>之前我们讲过，引用是必须有效的指针，而指针不一定是引用，在这里就得到了充分的体现。原始指针指向的数据不对的话，解引用有可能会导致段错误或其他未定义行为。因此引用转换为原始指针的时候，不需要包 unsafe，解引用原始指针的时候，要用 unsafe 包起来。这就是我们上面说的那 5 种被封印的能力中的第一种能力： <strong>在 unsafe Rust 中，可以解引用原始指针。</strong></p><p>一旦接触到了原始指针，也就开启了计算机底层系统的大门。你可以看我放在这里的两个链接，感受一下原始指针的复杂性。</p><ul><li><a href="https://doc.rust-lang.org/std/primitive.pointer.html" target="_blank" rel="noreferrer">https://doc.rust-lang.org/std/primitive.pointer.html</a></li><li><a href="https://doc.rust-lang.org/std/ptr/index.html" target="_blank" rel="noreferrer">https://doc.rust-lang.org/std/ptr/index.html</a></li></ul><h3 id="box-t-转成原始指针" tabindex="-1"><code>Box&lt;T&gt;</code> 转成原始指针 <a class="header-anchor" href="#box-t-转成原始指针" aria-label="Permalink to &quot;\`Box&lt;T&gt;\` 转成原始指针&quot;">​</a></h3><p><code>Box&lt;T&gt;</code> 是带所有权的智能指针，它有一个 <code>into_raw()</code> 函数可以转换成原始指针。这个转换对于内存里的资源没有影响。但是要再从 raw pointer 转回 Box 就要放在 unsafe 里包起来， <code>Box::from_raw()</code> 是 unsafe 的。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> my_speed</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">Box</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">&gt; </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> Box</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">new</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">88</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> my_speed</span><span style="color:#ABB2BF;">: *</span><span style="color:#C678DD;">mut</span><span style="color:#E5C07B;"> i32</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> Box</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">into_raw</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">my_speed</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">        let</span><span style="color:#E06C75;"> _</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> Box</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">from_raw</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">my_speed</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这实际上也是对原始指针解引用的一个变形，所以要放在 unsafe 块里。</p><h3 id="null-指针" tabindex="-1">null 指针 <a class="header-anchor" href="#null-指针" aria-label="Permalink to &quot;null 指针&quot;">​</a></h3><p>之前我们说过，Rust 中不存在 null/nil 值，所有的变量都必须初始化。这在 Safe Rust 里是正确的。但是在 Unsafe Rust 中，却提供了 null 指针的表示。</p><p>可以用 std::ptr 里的 <code>null()</code> 和 <code>null_mut()</code> 生成两种原始空指针。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    use</span><span style="color:#E5C07B;"> std</span><span style="color:#ABB2BF;">::ptr;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">: *</span><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> i32</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> ptr</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">null</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#61AFEF;">    assert!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">p</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">is_null</span><span style="color:#ABB2BF;">());</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> p</span><span style="color:#ABB2BF;">: *</span><span style="color:#C678DD;">mut</span><span style="color:#E5C07B;"> i32</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> ptr</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">null_mut</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#61AFEF;">    assert!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">p</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">is_null</span><span style="color:#ABB2BF;">());</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Rust 中为什么会有空指针存在？有什么作用呢？那是因为 C 语言中有空指针这个东西。为了与 C 打交道，Rust 中要有对应的设计，好与 C 库或者 C 应用程序对接，毕竟在 Rust 出来之前，C/C++ 已经建成了这个软件世界的地基。</p><h3 id="safe-与-unsafe-的边界" tabindex="-1">Safe 与 Unsafe 的边界 <a class="header-anchor" href="#safe-与-unsafe-的边界" aria-label="Permalink to &quot;Safe 与 Unsafe 的边界&quot;">​</a></h3><p>在 Rust 中，unsafe 函数必须在 unsafe 函数中调用，或使用 <code>unsafe {}</code> 块包起来调用。因此下面的代码是可以的：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> foo</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> my_num_ptr</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> &amp;</span><span style="color:#D19A66;">10</span><span style="color:#C678DD;"> as</span><span style="color:#ABB2BF;"> *</span><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> i32</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> my_speed_ptr</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> &amp;</span><span style="color:#C678DD;">mut</span><span style="color:#D19A66;"> 88</span><span style="color:#C678DD;"> as</span><span style="color:#ABB2BF;"> *</span><span style="color:#C678DD;">mut</span><span style="color:#E5C07B;"> i32</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">        println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;my_num is: {}&quot;</span><span style="color:#ABB2BF;">, *</span><span style="color:#E06C75;">my_num_ptr</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">        println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;my_speed is: {}&quot;</span><span style="color:#ABB2BF;">, *</span><span style="color:#E06C75;">my_speed_ptr</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#61AFEF;">    foo</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看到， <code>foo()</code> 函数中包含了 unsafe 块的调用。但是从 <code>main()</code> 函数的角度来看，它调用 <code>foo()</code> 时不需要在外面再套一层 <code>unsafe {}</code> 来调用了。这里实际体现了重要的一点， <strong>Unsafe 与 Safe 的边界</strong>。示例代码里两者的边界就在 <code>foo()</code> 函数中。</p><p>从 <code>main()</code> 的视角来看，它调用的 <code>foo()</code> 有可能是第三方库暴露出来的接口，并不知道里面具体的实现，只知道这个函数可以按 Safe Rust 的形式安全调用。这里的这个 <code>foo()</code> 就是 <strong>对 unsafe 代码的 safe 封装</strong>。</p><p>我们再来看一个实际一点的例子。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> std</span><span style="color:#ABB2BF;">::slice;</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> split_at_mut</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">values</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#C678DD;">mut</span><span style="color:#ABB2BF;"> [</span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">], </span><span style="color:#E06C75;">mid</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">usize</span><span style="color:#ABB2BF;">) -&gt; (&amp;</span><span style="color:#C678DD;">mut</span><span style="color:#ABB2BF;"> [</span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">], &amp;</span><span style="color:#C678DD;">mut</span><span style="color:#ABB2BF;"> [</span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">]) {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> len</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> values</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">len</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> ptr</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> values</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">as_mut_ptr</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#61AFEF;">    assert!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">mid</span><span style="color:#56B6C2;"> &lt;=</span><span style="color:#E06C75;"> len</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">        (</span></span>
<span class="line"><span style="color:#E5C07B;">            slice</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">from_raw_parts_mut</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">ptr</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">mid</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#E5C07B;">            slice</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">from_raw_parts_mut</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">ptr</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">add</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">mid</span><span style="color:#ABB2BF;">), </span><span style="color:#E06C75;">len</span><span style="color:#ABB2BF;"> - </span><span style="color:#E06C75;">mid</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#ABB2BF;">        )</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#C678DD;"> mut</span><span style="color:#E06C75;"> vector</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> vec!</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">5</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">6</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">left</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">right</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> split_at_mut</span><span style="color:#ABB2BF;">(&amp;</span><span style="color:#C678DD;">mut</span><span style="color:#E06C75;"> vector</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>上面函数将一个 i32 数组的 slice 可变引用分成了前后两段 slice 可变引用。这在 Safe Rust 是做不到的，因为同时对原数组存在了两个可变引用，详情请看 <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#creating-a-safe-abstraction-over-unsafe-code" target="_blank" rel="noreferrer">官方书</a>。</p><p>在 Unsafe Rust 中可以做到，但是 <code>slice::from_raw_parts_mut()</code> 只能用 <code>unsafe {}</code> 包起来调用。而对业务开发者来说，在 <code>main()</code> 函数中以 Safe Rust 的形式直接使用 <code>split_at_mut()</code> 就行了，一切就好像 <code>split_at_mut()</code> 是真正 safe 的一样。在这里，它确实是 safe 的，只不过这个 safe 不是由 Rustc 来保证的 safe，而是由我们程序员自己保证的 safe。我们知道我们在干什么，两个 slice 并不重叠，不会有问题。</p><p>如果打破砂锅问到底的话，是不是几乎所有的 Rust 底层都有这个问题？跟踪到最底层代码的话，是不是都是 unsafe 的？如果是，那么 Rust 所标榜的 safe，岂不是一个虚幻的空中楼阁？</p><p>你的猜测大体是正确的。</p><h3 id="极小化-unsafe-层" tabindex="-1">极小化 Unsafe 层 <a class="header-anchor" href="#极小化-unsafe-层" aria-label="Permalink to &quot;极小化 Unsafe 层&quot;">​</a></h3><p>从本质来说，世界是建立在 unsafe 上面的。</p><p>从硬件来说，我们编写程序来操作各种设备，内存、硬盘、显卡、网络设备等等，对它们的操作完全有可能是不安全的，这个错误可能来自各种层次，比如电源波动引起的故障、线路老化故障、晶体管损坏故障，甚至是太阳黑子爆发引起的故障等等。</p><p>从软件指令来说，当代码编译成二进制后，这个二进制可执行序列的威力是无穷大的，理论上可以对计算机内存和设备地址做任意访问，这也是 hack 行为的源头。只要 hacker 找到了你程序中的漏洞，它就可能在你的计算机中做任何危险的事情。这就是 C 这种靠指针吃饭的语言强大且危险的原因。</p><p>不管是从硬件层面还是软件层面，你的一个操作完全可能会得到一个未知的行为或未定义行为 <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html" target="_blank" rel="noreferrer">Undefined Behaviour</a>。 <strong>从 Safe Rust 的观点来看，一个会产生未定义行为的操作，就是 Unsafe 的</strong>。而 unsafe 的操作，都必须明确地放在 <code>unsafe {}</code> 块中隔离。</p><p>因此，在 Safe Rust 看来，威力过大的技能，比如原始指针的解引用，可能访问到未初始化的地址，或者是已经释放后的地址，因此它是 Unsafe 的；外部的 C/C++代码，它们都得靠程序员自己来保证安全性，因此它们是不可信任的，把它们都归类到 Unsafe 中；对外部设备的操作，已经超过内存资源的管理权限了，Rust 自己鞭长莫及，因此把它归为不信任，归类到 Unsafe 中。</p><p>于是我们可以看到，Rust 将所有代码分割成了 Safe 的和 Unsafe 的两块，两块之间就通过明确的 <code>unsafe {}</code> 标识来隔离，这是 Rust 的基本世界观。</p><p>在这个世界观之上，基于 Rust 的软件体系还有一套抽象哲学——当需要 Unsafe 时，应该把它封装在一个极小层（minimalist layer），然后在它的上面建立上层建筑。</p><p>也就是说，如果不得不用 Unsafe 代码，那请封装尽量薄的一层 unsafe layer，而在其之上完全使用 safe rust 编写。这个时候就可以回答这个问题了：如果是，那么 Rust 所标榜的 safe，岂不是一个虚幻的空中楼阁？</p><p>Rust 通过这套方法学，让 Safe Rust 的代码部分可以自证安全，而 Unsafe Rust 的代码部分由程序员来保证安全。你可以想象一下，如果一个系统有 10 万行 Rust 代码，98%的代码是 Safe Rust，2%的代码是 Unsafe Rust，那么需要由人来审计的代码就只有 2 千行。那我们就可以把所有精力集中在这 2 千行代码的审计上，确保它们不会出问题。或者说即使出了问题，也可以去这 2 千行代码中去找原因。</p><p>而如果同样的这套系统，由 10 万行 C/C++代码来实现，那么审计的时候，就必须审计 10 万行代码，也就是 50 倍的审计工作量。遇到问题，也是在 10 万行代码里面去找原因。这个成本完全不可比拟。</p><p>因此，Rust 所标榜的 safe，完全不是空中楼阁。不仅不是空中楼阁，还是非常切实可行的一套软件工程方法学。</p><h2 id="标准库中的-unsafe-示例" tabindex="-1">标准库中的 unsafe 示例 <a class="header-anchor" href="#标准库中的-unsafe-示例" aria-label="Permalink to &quot;标准库中的 unsafe 示例&quot;">​</a></h2><p>Rust 标准库中有一些 unsafe 函数，我们来看两个。</p><h3 id="slice-的-get-unchecked-函数" tabindex="-1">Slice 的 <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked" target="_blank" rel="noreferrer">get_unchecked()</a> 函数 <a class="header-anchor" href="#slice-的-get-unchecked-函数" aria-label="Permalink to &quot;Slice 的 [get_unchecked()](https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked) 函数&quot;">​</a></h3><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> x</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> &amp;[</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    unsafe</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">        assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">get_unchecked</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">), &amp;</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在有 <code>get()</code> 的情况下，Rust 标准库还提供这个 <code>get_unchecked()</code> 函数，原因其实也很简单，因为 <code>get()</code> 会进行边界检查，而 <code>get_unchecked()</code> 不会。在有些密集运算的情况下，边界检查对性能影响比较大，因此提供一个不做边界检查的版本，用来追求极致的速度。毕竟，Rust 是一门与 C/C++在同一层次的语言，不应该给 Rust 人为呆板地设置障碍，比如必须使用边界检查的安全版本。</p><h3 id="str-的-from-utf8-unchecked-函数" tabindex="-1">str 的 <a href="https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html" target="_blank" rel="noreferrer">from_utf8_unchecked()</a> 函数 <a class="header-anchor" href="#str-的-from-utf8-unchecked-函数" aria-label="Permalink to &quot;str 的 [from_utf8_unchecked()](https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html) 函数&quot;">​</a></h3><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    use</span><span style="color:#E5C07B;"> std</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // some bytes, in a vector</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> sparkle_heart</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> vec!</span><span style="color:#ABB2BF;">[</span><span style="color:#D19A66;">240</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">159</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">146</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">150</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> sparkle_heart</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> unsafe</span><span style="color:#ABB2BF;"> { </span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">from_utf8_unchecked</span><span style="color:#ABB2BF;">(&amp;</span><span style="color:#E06C75;">sparkle_heart</span><span style="color:#ABB2BF;">) };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;💖&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">sparkle_heart</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个函数我们在 <a href="https://time.geekbang.org/column/article/720426" target="_blank" rel="noreferrer">第 4 讲</a> 聊字符串的时候提到过，它不检查字节序列为有效的 UTF8 编码，因此转出来可能不是有效的字符串。原因也很简单，还是为了性能。在有些场合下，绝对的性能就是绝对的王道，Rust 不给你设置天花板。</p><h2 id="外部函数接口-ffi" tabindex="-1">外部函数接口 FFI <a class="header-anchor" href="#外部函数接口-ffi" aria-label="Permalink to &quot;外部函数接口 FFI&quot;">​</a></h2><p>这里我提出一个问题，你来想一下。 <strong>一门编程语言如何与另一门编程语言在语言层面交互呢？</strong> 这个问题还真不好办。</p><p>事实上，像 JavaScript 就不太可能直接与 Python 进行交互。大部分语言之间是没办法直接交互的。但是，历史却留下一个有趣且可贵的遗产——所有主流语言基本都能与 C 语言交互，因为它们都需要用 C 来写扩展，提升性能。当然 C++ 是在语言层面直接包含了 C，这个另当别论。</p><p>Rust 在设计之初， <strong>与 C 实现二进制级的兼容</strong> 就是一项重要目标。二进制兼容的意思其实就是 Rust 可以选择编译目标为符合 C 语言 <a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank" rel="noreferrer">ABI</a>（Application Binary Interface）的二进制格式。</p><p>ABI 包含数据结构怎么对齐、存储，函数如何传参、返参、调用二进制格式信息等，而 Rust 就支持编译到遵循 C ABI 的二进制库目标上。这意味着用 Rust 编写的共享动态库 <code>.so</code>、 <code>.dll</code> 等在外界看来，与用 C 编译成的 <code>.so</code>、 <code>.dll</code> 动态库没什么区别，你甚至不知道是什么语言写成的。因此，Rust 编写的动态库也能被 Python、JavaScript、Go、Java 等其他语言调用，它们都支持 C ABI 动态库。</p><p>另一方面， <strong>C 实现的动态库也能被 Rust 无缝调用</strong>，因为 Rust 能识别 C ABI。一个 C 的库函数，在 C 应用中运行和在 Rust 应用中运行没什么区别，性能也没有损失，就好像没有跨语言一样，这就是 Rust 的魔法所在。</p><p>这点与其他动态语言如 Python、JavaScript 等就有很大差别。这些动态语言到 C 语言的 FFI 边界会有不小的额外消耗。究其原因，就是因为入参与返参会有类型转换的工作，而在这些动态语言中，类型是被 GC 托管的，这里面就有很多细节要处理，会带来额外的消耗。而 Rust 就不存在这个问题，前面我们提示，Unsafe Rust 里面住着一位 C 国王，就好像一家人一样，或者至少是关系很近的亲戚。</p><p>尽管如此，有关 Rust 与 C 的 FFI 的知识点还是非常多的，有许多要注意的地方，也不是一下子就能掌握的，需要在实际需求产生时抠各种细节。另外，Rust 中的 Unsafe 其实要求你考虑更多，因为它比传统的 C 语言工程更详尽地考虑了 <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html" target="_blank" rel="noreferrer">未定义行为</a> 的概念，它要求你尽可能地考虑周全， <strong>因为封装给 Safe Rust 的功能被要求不能产生任何未定义行为</strong>。所以 Rust 不仅是工程上的创新，在学术理论上也有一定程度的创新，目标就是写出更健壮的代码。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p><img src="`+o+'" alt=""></p><p>这节课我们了解了有关 Rust 中 Unsafe 和 FFI 的基础概念。我们进入 Unsafe Rust 后，就可以使用一些必杀技能了。这些技能威力巨大，但是也充满风险，需要由程序员自己来保证使用上的安全性。</p><p>我们说 Rust 由三个王国组成，既然是王国，那么内容铁定不会少。从 <code>unsafe {}</code> 这个大门进入 Unsafe Rust，实际就进入了计算机体系结构的底层，你会发现一片美丽新世界。这个世界中有 OS、内存结构、对齐、锁、ABI、调度、指令集、总线协议等等眼花缭乱的新东西。我们之前提到过一种观点， <strong>学习 Rust 就是学习 CS 计算机科学，Unsafe Rust 就是下沉之门</strong>。</p><p>Rust 与 C 有正统的血脉关系，可以实现真正的双向互通，而没有边界性能损失。这预示着未来在嵌入式、工业控制、航空航天、自动驾驶等领域，Rust 都有非常大的潜力成为主流选手。绝大部分的人写熟了 Rust 以后就再也不想写 C 了，编程体验完全不可同日而语。长期来看，C 语言的份额会逐渐缓慢地萎缩到一个比较小的范围，而 Rust 则会担当起 C 语言之前的重任。</p><p>我们要理解 Rust 将 Safe 建立在 Unsafe 的这套方法之上，这也是软件工业界几十年探索的一个重要成果。所以你会听到 NASA、微软等机构呼吁新的软件开发不要再使用 C/C++了，而应该用“安全编程”的语言来取代。从这个意义上来讲，Rust 是划时代的语言。以后的语言可能会这么分类：Rust 之后的语言与 Rust 之前的语言。</p><p>下节课我们会将 Rust 代码导出给 C 语言使用，并且进一步导出给 Python 使用，给 Python 实现一个自定义扩展。</p><h2 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h2><p>Unsafe Rust 比 C 语言更安全吗，为什么？欢迎你把自己的思考分享到评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>',92)]))}const F=n(r,[["render",t]]);export{b as __pageData,F as default};
