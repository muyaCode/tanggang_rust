import{_ as n,c as a,o as l,ag as p}from"./chunks/framework.D2WelYEY.js";const e="/tanggang_rust/assets/a005e69a5cfdacd5a93ae841a32c07aa.C6OA2A6l.jpg",b=JSON.parse('{"title":"17 ｜ tokio 编程： Rust 异步编程还有哪些需要注意的点？","description":"","frontmatter":{},"headers":[],"relativePath":"Document/17｜tokio编程：Rust异步编程还有哪些需要注意的点？.md","filePath":"Document/17｜tokio编程：Rust异步编程还有哪些需要注意的点？.md","lastUpdated":1740766764000}'),o={name:"Document/17｜tokio编程：Rust异步编程还有哪些需要注意的点？.md"};function c(r,s,t,i,y,B){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="_17-tokio-编程-rust-异步编程还有哪些需要注意的点" tabindex="-1">17 ｜ tokio 编程： Rust 异步编程还有哪些需要注意的点？ <a class="header-anchor" href="#_17-tokio-编程-rust-异步编程还有哪些需要注意的点" aria-label="Permalink to &quot;17 ｜ tokio 编程： Rust 异步编程还有哪些需要注意的点？&quot;">​</a></h1><p>你好，我是 Mike。前面几节课，我们学习了 Rust 异步编程和 tokio 的基础知识，我们先来简单回顾下。</p><ol><li><code>async/.await</code> 语法</li><li>tokio 基本概念和组件</li><li>使用 tokio 编写一个网络并发应用</li><li>使用 Arc 和 Mutex 在多个 task 之间共享数据</li><li>在并发 task 之间使用 Channel 传递数据</li></ol><p>通过学习这些内容，你应该已经能使用 tokio 开发 Rust 异步并发应用了。这节课，我们对 Rust 异步并发相关的知识点来做一点补遗。</p><h2 id="async-其他知识点" tabindex="-1">async 其他知识点 <a class="header-anchor" href="#async-其他知识点" aria-label="Permalink to &quot;async 其他知识点&quot;">​</a></h2><p>Rust 代码中的 async 函数，其实和 Rust 的普通函数是不相容的。async Rust 就好像是 Rust 语言里的一个独立王国。</p><h3 id="async-代码的传染性" tabindex="-1">async 代码的传染性 <a class="header-anchor" href="#async-代码的传染性" aria-label="Permalink to &quot;async 代码的传染性&quot;">​</a></h3><p>Rust async 代码具有传染性。前面我们给出了使用 <code>async/.await</code> 的两条规则。</p><ol><li>async 函数或 block 只有被 <code>.await</code> 后才被驱动。</li><li><code>.await</code> 只能在 async 函数或 block 中使用。</li></ol><p>这就导致在业务代码中（非 tokio 那个顶层 Runtime 代码），如果你需要调用一个 async 函数，那么你也需要让你现在这个调用者函数也是 async 的，你可以看我给出的这个例子。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 我们定义foo1为一个异步函数</span></span>
<span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> foo1</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#D19A66;">  100</span><span style="color:#E5C07B;">u32</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 我需要在foo2函数中调用foo1，那么这个foo2也必需要是async函数</span></span>
<span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> foo2</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">  foo1</span><span style="color:#ABB2BF;">().</span><span style="color:#C678DD;">await</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 我需要在foo3函数中调用foo2，那么这个foo3也必需要是async函数</span></span>
<span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> foo3</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">  foo2</span><span style="color:#ABB2BF;">().</span><span style="color:#C678DD;">await</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">#[tokio::main]</span></span>
<span class="line"><span style="color:#C678DD;">async</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">  let</span><span style="color:#E06C75;"> num</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> foo3</span><span style="color:#ABB2BF;">().</span><span style="color:#C678DD;">await</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#61AFEF;">  println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;{}&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">num</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>这就叫作 async 代码的传染性。这种传染性是由 Rust 的 async 语法带来的。</p><blockquote><p>注：Rust 中还有一个语法具有传染性——类型参数 T。</p></blockquote><p>但是实际工作中，我们经常会遇到异步代码与同步代码混合使用的情况。这类情况应该怎么处理呢？下面我们分情况来分析。</p><h3 id="async-代码环境中的同步代码" tabindex="-1">async 代码环境中的同步代码 <a class="header-anchor" href="#async-代码环境中的同步代码" aria-label="Permalink to &quot;async 代码环境中的同步代码&quot;">​</a></h3><p>常见的同步代码分两类，一类是直接在内存里的简单操作，比如 <code>vec.push()</code> 这种 API 接口的调用。这类操作在 std Rust 里怎么使用在 async Rust 里就怎么使用，一样的。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> foo1</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">  let</span><span style="color:#C678DD;"> mut</span><span style="color:#E06C75;"> vec</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> Vec</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">new</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#E06C75;">  vec</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">push</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">10</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>另外有一类操作，要么是需要执行长时间的计算，要么是需要调用第三方已经写好的同步库的代码，你没有办法去修改它。对于这类函数的调用，你当然也可以直接调用：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> foo1</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">  let</span><span style="color:#E06C75;"> result</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> a_heavy_work</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样写当然是可以运行的，但会有性能上的问题：它会阻塞当前正在跑这个异步代码的系统线程（OS Thread，由 tokio 来管理维护），所以当前的这个系统线程就会被卡住，而不能再跑其他异步代码了。</p><p>好消息是，tokio 专门给我们提供了另外的设施来处理这种情况，就是 <code>task::spawn_blocking()</code> 函数。你可以看一下它的使用方法。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">#[tokio::main]</span></span>
<span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 此任务跑在一个单独的线程中</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> blocking_task</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> tokio</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">task</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">spawn_blocking</span><span style="color:#ABB2BF;">(</span><span style="color:#56B6C2;">||</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 在这里面可以执行阻塞线程的代码</span></span>
<span class="line"><span style="color:#ABB2BF;">    });</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 像下面这样用同样的方式等待这种阻塞式任务的完成</span></span>
<span class="line"><span style="color:#E06C75;">    blocking_task</span><span style="color:#ABB2BF;">.</span><span style="color:#C678DD;">await</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">unwrap</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>只需要把 CPU 计算密集型任务放到 <code>task::spawn_blocking()</code> 里就可以了，tokio 会帮我们单独开一个新的系统线程，来专门跑这个 CPU 计算密集型的 task。然后和普通的 tokio task 一样，可以通过 await 来获取它的结果，当然，也可以用 Oneshot channel 把结果返回回来。</p><p>给这种 CPU 计算密集型任务单独开一个系统线程运行，就能保证我们当前跑异步任务的系统线程不会被这个 CPU 计算密集型任务占据，导致异步并发能力下降，因此我们得到了一个比较好的方案。</p><p>一般来讲，主体是 async 代码，只有一些小部分是同步代码的时候，使用 <code>task::spawn_blocking()</code> 比较合适。</p><h3 id="同步代码环境中的-async-代码" tabindex="-1">同步代码环境中的 async 代码 <a class="header-anchor" href="#同步代码环境中的-async-代码" aria-label="Permalink to &quot;同步代码环境中的 async 代码&quot;">​</a></h3><p>那如果主体代码是同步代码（或者叫 std Rust 代码），但是局部想调用一些 async 接口，比如 db driver 只提供了 async 封装，像这种情况下该怎么办呢？</p><p>回想一下我们前面讲到的，展开 <code>#[tokio::main]</code>。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">#[tokio::main]</span></span>
<span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#61AFEF;">    println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Hello world&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>展开后，其实是下面这个样子：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#E5C07B;">    tokio</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">runtime</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">Builder</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">new_multi_thread</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">        .</span><span style="color:#61AFEF;">enable_all</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">        .</span><span style="color:#61AFEF;">build</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">        .</span><span style="color:#61AFEF;">unwrap</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">        .</span><span style="color:#61AFEF;">block_on</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">async</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#61AFEF;">            println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Hello world&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">        })</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>类似地，我们要在同步风格的代码中执行 async 代码，只需要手动 block_on 这段异步代码就可以了。除了默认的系统多线程 Runtime 之外，tokio 专门为这种临时的（以及测试的）场景提供了另一种单系统线程的 runtime，就是 <code>new_current_thread()</code>。它的意思是就在当前程序执行的线程中建立 tokio Runtime，异步任务就跑在当前这个线程中。比如：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> foo1</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#D19A66;">    10</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> foo</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> rt</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> tokio</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">runtime</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">Builder</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">new_current_thread</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">          .</span><span style="color:#61AFEF;">enable_all</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">          .</span><span style="color:#61AFEF;">build</span><span style="color:#ABB2BF;">().</span><span style="color:#61AFEF;">unwrap</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> num</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> rt</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">block_on</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">foo1</span><span style="color:#ABB2BF;">());  </span><span style="color:#7F848E;font-style:italic;">// 注意这一句的 foo1()，调用了此异步函数</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 或者像下面这样写</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //let num = rt.block_on(async {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //    foo1().await</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //});</span></span>
<span class="line"><span style="color:#61AFEF;">    println!</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;{}&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">num</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#61AFEF;">    foo</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 输出</span></span>
<span class="line"><span style="color:#D19A66;">10</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>就通过这种方式，我们在主体为 std Rust 的代码中，成功地调用了局部的 async Rust 代码，并得到了这段局部异步代码的返回值。</p><h2 id="rust-async-实现原理" tabindex="-1">Rust async 实现原理 <a class="header-anchor" href="#rust-async-实现原理" aria-label="Permalink to &quot;Rust async 实现原理&quot;">​</a></h2><p>Rust 的 async 实现实际采用的是一种无栈协程（Stackless Coroutine）方案。它的实现是非常高效的，性能在所有支持异步语法的语言中属于最高的那一级，非常厉害。</p><h3 id="rust-async-的背后原理" tabindex="-1">Rust async 的背后原理 <a class="header-anchor" href="#rust-async-的背后原理" aria-label="Permalink to &quot;Rust async 的背后原理&quot;">​</a></h3><p>Rust 语言实际会把 async 语法编译成 std Rust 中的状态机，然后通过运行时底层的 poll 机制来轮询这个状态机的状态。所以本质上来讲， <code>async/.await</code> 语法只是语法糖。</p><p>简单来说，Rust 会把一个 async 函数转换成另一种东西，你可以看一下我给出的转换示例。</p><p>async 函数：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> foo1</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">u32</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#D19A66;">  10</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>转换后：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">struct</span><span style="color:#E5C07B;"> FutureA</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    ...</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">impl</span><span style="color:#E5C07B;"> Future</span><span style="color:#C678DD;"> for</span><span style="color:#E5C07B;"> FutureA</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    ...</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>具体的转换和实现细节我们现在不需要掌握，只需要知道，Rust 的这种实现并不是像 Go 或 Java 那样，在系统级线程的基础上，单独实现了一层结合 GC 内存管理且具有完整屏蔽性的轻量级线程，它没有选择在 OS 应用之间引入一个层（layer），而是在结构体之上构建一个状态机，以零成本抽象（zero cost abstract）为原则，尽量少地引入额外的消耗，配合 <code>async/.await</code> 语法糖，来达到简化程序员开发难度的效果。</p><p>这种方案成功地让 Rust 的异步并发能力达到业界顶尖水平。Rust 异步语法从提案到稳定推出，前后经历了大量的讨论和修改，花了将近 5 年的时间，非常不容易，是整个 Rust 社区共同努力的结果，期间的故事称得上是全世界开源协作的典范。</p><h3 id="其他一些要注意的问题" tabindex="-1">其他一些要注意的问题 <a class="header-anchor" href="#其他一些要注意的问题" aria-label="Permalink to &quot;其他一些要注意的问题&quot;">​</a></h3><p>Rust async 编程也一直处于不断地发展过程中，比如目前在 trait 里，就不能定义 async 方法，比如：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">trait</span><span style="color:#E5C07B;"> MyTrait</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">    async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> f</span><span style="color:#ABB2BF;">() {}</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 编译错误</span></span>
<span class="line"><span style="color:#E06C75;">error</span><span style="color:#ABB2BF;">[</span><span style="color:#E5C07B;">E0706</span><span style="color:#ABB2BF;">]: </span><span style="color:#C678DD;">trait</span><span style="color:#E06C75;"> fns</span><span style="color:#E06C75;"> cannot</span><span style="color:#E06C75;"> be</span><span style="color:#E06C75;"> declared</span><span style="color:#ABB2BF;"> \`</span><span style="color:#C678DD;">async</span><span style="color:#ABB2BF;">\`</span></span>
<span class="line"><span style="color:#ABB2BF;"> --&gt; </span><span style="color:#E06C75;">src</span><span style="color:#ABB2BF;">/</span><span style="color:#E06C75;">main</span><span style="color:#ABB2BF;">.rs:</span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">5</span></span>
<span class="line"><span style="color:#56B6C2;">  |</span></span>
<span class="line"><span style="color:#D19A66;">4</span><span style="color:#56B6C2;"> |</span><span style="color:#C678DD;">     async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> f</span><span style="color:#ABB2BF;">() {}</span></span>
<span class="line"><span style="color:#56B6C2;">  |</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>为了解决这个问题，我们可以引入 <code>async_trait crate</code> 的 <code>async_trait</code> 宏来暂时过渡。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> async_trait</span><span style="color:#ABB2BF;">::async_trait;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">#[async_trait]    </span><span style="color:#7F848E;font-style:italic;">// 定义时加</span></span>
<span class="line"><span style="color:#C678DD;">trait</span><span style="color:#E5C07B;"> MyTrait</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">    async</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> f</span><span style="color:#ABB2BF;">() {}</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">struct</span><span style="color:#E5C07B;"> Modal</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">#[async_trait]    </span><span style="color:#7F848E;font-style:italic;">// impl 时也要加</span></span>
<span class="line"><span style="color:#C678DD;">impl</span><span style="color:#E5C07B;"> MyTrait</span><span style="color:#C678DD;"> for</span><span style="color:#E5C07B;"> Modal</span><span style="color:#ABB2BF;"> {}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>请注意上述代码中，在定义 trait 和 impl trait 的时候，都需要添加 <code>#[async_trait]</code> 属性宏来标注。添加了这个宏标注后，trait 里的 async fn 就可以像普通的 async fn 那样在异步代码中被调用了。</p><p>目前使用这个宏会有一点性能上的开销，好在 trait 中的 async fn 这个特性 Rust 官方也快稳定下来了，估计在 1.75 版本正式推出，到时候就可以去掉这个宏标注了。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>这节课我补充了 Rust 异步并发编程中剩下的一些需要注意的知识点。</p><p>我们一共花了 5 节课的时间来讲解 async Rust 和 tokio 的使用，这是因为异步并发编程对于一个场景，也就是高性能高并发服务来说，至关重要。在后面的 Web 后端服务开发实战部分，我们还会继续基于 tokio 进行讲解。</p><p><img src="`+e+'" alt="图片"></p><h2 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h2><p>你是如何理解 “async Rust 是一个独立王国”这种说法的？欢迎你分享自己的见解，我们一起讨论，如果你觉得这节课的内容对你有帮助的话，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p><p>参考链接： <a href="https://tokio.rs/tokio/topics/bridging" target="_blank" rel="noreferrer">https://tokio.rs/tokio/topics/bridging</a></p>',59)]))}const d=n(o,[["render",c]]);export{b as __pageData,d as default};
