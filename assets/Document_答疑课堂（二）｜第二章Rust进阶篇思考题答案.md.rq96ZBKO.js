import{_ as e,c as t,o as s,ag as n}from"./chunks/framework.D2WelYEY.js";const h=JSON.parse('{"title":"答疑课堂（二）｜第二章 Rust 进阶篇思考题答案","description":"","frontmatter":{},"headers":[],"relativePath":"Document/答疑课堂（二）｜第二章Rust进阶篇思考题答案.md","filePath":"Document/答疑课堂（二）｜第二章Rust进阶篇思考题答案.md","lastUpdated":1740766764000}'),r={name:"Document/答疑课堂（二）｜第二章Rust进阶篇思考题答案.md"};function o(l,a,i,c,p,m){return s(),t("div",null,a[0]||(a[0]=[n(`<h1 id="答疑课堂-二-第二章-rust-进阶篇思考题答案" tabindex="-1">答疑课堂（二）｜第二章 Rust 进阶篇思考题答案 <a class="header-anchor" href="#答疑课堂-二-第二章-rust-进阶篇思考题答案" aria-label="Permalink to &quot;答疑课堂（二）｜第二章 Rust 进阶篇思考题答案&quot;">​</a></h1><p>你好，我是 Mike。</p><p>这节课我们继续来看第二章的课后思考题答案。还是和之前一样，最好是自己学完做完思考题之后再来看答案，效果会更好。话不多说，我们直接开始吧！</p><h2 id="进阶篇" tabindex="-1"><strong>进阶篇</strong> <a class="header-anchor" href="#进阶篇" aria-label="Permalink to &quot;**进阶篇**&quot;">​</a></h2><h3 id="_12-智能指针-从所有权和引用看智能指针的用法" tabindex="-1"><a href="https://time.geekbang.org/column/article/725815?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noreferrer">12 ｜智能指针：从所有权和引用看智能指针的用法</a> <a class="header-anchor" href="#_12-智能指针-从所有权和引用看智能指针的用法" aria-label="Permalink to &quot;[12 ｜智能指针：从所有权和引用看智能指针的用法](https://time.geekbang.org/column/article/725815?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search)&quot;">​</a></h3><h4 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><p>你试着打开示例中的这两句，看看报错信息，然后分析一下是为什么？</p><div class="language-Rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">    // arced.play_mutref();</span><span style="color:#7F848E;font-style:italic;">  // 不能用</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // arced.play_own();</span><span style="color:#7F848E;font-style:italic;">     // 不能用</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>Arc 本质上是个引用，所以不允许同时存在可变引用或者移动。play_boxown() 和 play_own() 只能同时打开一个，这两个方法调用都会消耗所有权，导致没法调用另外一个。</p><p>答案来自 Taozi 和 Michael</p><h3 id="_13-异步并发编程-为什么说异步并发编程是-rust-的独立王国" tabindex="-1"><a href="https://time.geekbang.org/column/article/725837?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noreferrer">13 ｜异步并发编程：为什么说异步并发编程是 Rust 的独立王国？</a> <a class="header-anchor" href="#_13-异步并发编程-为什么说异步并发编程是-rust-的独立王国" aria-label="Permalink to &quot;[13 ｜异步并发编程：为什么说异步并发编程是 Rust 的独立王国？](https://time.geekbang.org/column/article/725837?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search)&quot;">​</a></h3><h4 id="思考题-1" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-1" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><p>为什么我们要把 async Rust 叫做“独立王国”呢？</p><h4 id="答案-1" tabindex="-1">答案 <a class="header-anchor" href="#答案-1" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>因此 async Rust 代码是在一个 Runtime 里面执行的，而 std Rust 的代码不需要这个额外的 Runtime，因此说它是独立王国。</p><p>另一方面，在 Rust 中，异步编程是使用 async/await 语法，这种语法具有可传染性，与 std Rust 代码也可以明显区分开，因此它像一个独立王国。</p><h3 id="_14-tokio-编程-一-如何编写一个网络命令行程序" tabindex="-1"><a href="https://time.geekbang.org/column/article/726207?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noreferrer">14 ｜ Tokio 编程（一）：如何编写一个网络命令行程序？</a> <a class="header-anchor" href="#_14-tokio-编程-一-如何编写一个网络命令行程序" aria-label="Permalink to &quot;[14 ｜ Tokio 编程（一）：如何编写一个网络命令行程序？](https://time.geekbang.org/column/article/726207?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search)&quot;">​</a></h3><h4 id="思考题-2" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-2" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><ol><li>EOF 是什么，什么时候会碰到 EOF？</li><li><code>stream.read_to_end()</code> 接口能读完网络连接中的数据吗？</li></ol><h4 id="答案-2" tabindex="-1">答案 <a class="header-anchor" href="#答案-2" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>EOF 是 End of file。在 Linux 万物皆 file 的情况下，connection 也可以是一个 file。所以，当 Connection 关闭的时候，就会产生 EOF。</p><p><code>stream.read_to_end()</code> 是持续 <code>read()</code> 直到 EOF，因此能够读完网络里的数据，如果使用 <code>stream.read_to_end(&amp;mut buf).await?;</code> 读取的话，会持续 wait，直到连接关闭才能进行后续的操作。</p><p>答案来自 PEtFiSh</p><h3 id="_15-tokio-编程-二-如何在-tokio-多任务间操作同一片数据" tabindex="-1"><a href="https://time.geekbang.org/column/article/728055?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noreferrer">15 ｜ Tokio 编程（二）：如何在 Tokio 多任务间操作同一片数据？</a> <a class="header-anchor" href="#_15-tokio-编程-二-如何在-tokio-多任务间操作同一片数据" aria-label="Permalink to &quot;[15 ｜ Tokio 编程（二）：如何在 Tokio 多任务间操作同一片数据？](https://time.geekbang.org/column/article/728055?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search)&quot;">​</a></h3><h4 id="思考题-3" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-3" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><p>下面这两句的意义是什么，第一行会阻塞第二句吗？</p><div class="language-Rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E06C75;"> _</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> task_a</span><span style="color:#ABB2BF;">.</span><span style="color:#C678DD;">await</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">unwrap</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#E06C75;"> _</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> task_b</span><span style="color:#ABB2BF;">.</span><span style="color:#C678DD;">await</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">unwrap</span><span style="color:#ABB2BF;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="答案-3" tabindex="-1">答案 <a class="header-anchor" href="#答案-3" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>await 代码会持续等待直到任务结束，因此在 main thread 里第一行会阻塞第二行。但这不会让 task_a 阻塞 task_b。加入 await 可以使最后的 println!打印两个任务执行完以后被修改的 db 值，如果不加入 await。有一定几率最后 println!打印的还是原始的 db。</p><p>答案来自 PEtFiSh</p><h3 id="_16-tokio-编程-三-如何用-channel-在不同任务间进行通信" tabindex="-1"><a href="https://time.geekbang.org/column/article/728107?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noreferrer">16 ｜ Tokio 编程（三）：如何用 channel 在不同任务间进行通信？</a> <a class="header-anchor" href="#_16-tokio-编程-三-如何用-channel-在不同任务间进行通信" aria-label="Permalink to &quot;[16 ｜ Tokio 编程（三）：如何用 channel 在不同任务间进行通信？](https://time.geekbang.org/column/article/728107?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search)&quot;">​</a></h3><h4 id="思考题-4" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-4" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><p>从任务中搜集返回结果有几种方式？</p><h4 id="答案-4" tabindex="-1">答案 <a class="header-anchor" href="#答案-4" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>从任务收集返回结果的方式有：</p><ol><li>任务直接返回值，然后通过 handler 取回，比如 <code>a = task_a.await.unwrap();</code>。</li><li>通过锁的方式直接写在目标位置</li><li>通过 channel 的形式传递结果</li><li>似乎也可以 unsafe 来写全局变量。</li></ol><p>答案来自 PEtFiSh</p><h3 id="_17-tokio-编程-四-rust-异步并发还有哪些需要关注的点" tabindex="-1"><a href="https://time.geekbang.org/column/article/728198?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noreferrer">17 | Tokio 编程（四）：Rust 异步并发还有哪些需要关注的点？</a> <a class="header-anchor" href="#_17-tokio-编程-四-rust-异步并发还有哪些需要关注的点" aria-label="Permalink to &quot;[17 | Tokio 编程（四）：Rust 异步并发还有哪些需要关注的点？](https://time.geekbang.org/column/article/728198?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search)&quot;">​</a></h3><h4 id="思考题-5" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-5" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><p>你是如何理解 “async Rust 是一个独立王国”这种说法的？</p><h4 id="答案-5" tabindex="-1">答案 <a class="header-anchor" href="#答案-5" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>略</p><h3 id="_18-错误处理系统-rust-中错误是如何被传递并处理的" tabindex="-1"><a href="https://time.geekbang.org/column/article/729009" target="_blank" rel="noreferrer">18 | 错误处理系统：Rust 中错误是如何被传递并处理的？</a> <a class="header-anchor" href="#_18-错误处理系统-rust-中错误是如何被传递并处理的" aria-label="Permalink to &quot;[18 | 错误处理系统：Rust 中错误是如何被传递并处理的？](https://time.geekbang.org/column/article/729009)&quot;">​</a></h3><h4 id="思考题-6" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-6" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><ol><li>请你查阅 Rust std 资料，并说说对 std::error::Error 的理解。</li><li>请说明 anyhow::Error 与自定义枚举类型用作错误的接收时的区别。</li></ol><h4 id="答案-6" tabindex="-1">答案 <a class="header-anchor" href="#答案-6" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>std::error::Error 是 Rust 标准库中的 trait，该 trait 表示可能的错误类型的共同行为，这些错误类型通常都表示了一个失败的操作或无效的输入。实现 Error trait 的类型必须提供一个错误描述和一个可操作性的字符串，通常用于打印错误信息。</p><p>anyhow::Error 是一个第三方 Rust 库，它提供了一种用于简化错误处理的方式，该库提供了一个 Error 类型，能够自动收集多个错误信息，并返回一个更易于调试和处理的错误类型。</p><p>与自定义枚举类型相比，使用 anyhow::Error 具有以下优点：</p><ol><li><p>多态性：anyhow::Error 是一个特殊的错误类型，可以表示任何可能失败的操作，并且可以方便地传递错误信息和上下文，从而使错误处理更加灵活和方便。</p></li><li><p>方便处理：anyhow::Error 提供了一组常用的操作，如错误信息的格式化和日志记录等，这些操作相对繁琐，如果使用自定义枚举类型实现会相对麻烦和复杂。</p></li><li><p>减少代码重复：使用 anyhow::Error 可以排除许多写错误处理代码的繁琐重复的代码，提高代码可读性和可维护性。</p></li></ol><p>而在使用自定义枚举类型来接收错误时，你需要眼睛注意只能返回对应的错误类型，因此可能需要对函数中的一些操作手动作类型转换（map_error）。不像 <code>anyhow::Error</code> 这样可以一股脑直接扔回去。也就是说使用自定义枚举类型来接收错误的心智负担会大一点。</p><h3 id="_19-rust-的宏体系-为自己的项目写一个简单的声明宏" tabindex="-1"><a href="https://time.geekbang.org/column/article/731043" target="_blank" rel="noreferrer">19 ｜ Rust 的宏体系：为自己的项目写一个简单的声明宏</a> <a class="header-anchor" href="#_19-rust-的宏体系-为自己的项目写一个简单的声明宏" aria-label="Permalink to &quot;[19 ｜ Rust 的宏体系：为自己的项目写一个简单的声明宏](https://time.geekbang.org/column/article/731043)&quot;">​</a></h3><h4 id="思考题-7" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-7" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><p>说一说 <code>allow, warn, deny, forbid</code> 几个属性的意义和用法。</p><h4 id="答案-7" tabindex="-1">答案 <a class="header-anchor" href="#答案-7" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>在 Rust 中，allow、warn、deny 和 forbid 是四个控制编译器警告和错误输出的属性。</p><ol><li>allow：允许代码中出现这些警告，编译器不会输出警告信息。</li><li>warn：将警告转换为编译器的错误级别，编译器会在警告信息后面输出错误信息，但不会阻止代码的编译。</li><li>deny：将警告变为编译错误，编译器会在错误信息后面输出警告信息，并且由于错误级别的提高，代码无法编译通过。</li><li>forbid：严格禁止代码中出现这些警告，如果代码中出现了这些警告，就会直接报错并停止编译。</li></ol><p>这些属性通常用于优化编译器输出，使输出更加简洁和准确，并降低代码中不良代码的风险。一般情况下，allow 属性用于代码库中的不重要代码部分，warn 用于需要注意但不会造成严重后果的代码部分，deny 用于那些可能会导致问题的代码部分，而 forbid 则用于绝对不能出现问题的代码部分。</p><p>例如，在 Rust 中可以这样使用这些属性：</p><div class="language-Rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">#[allow(dead_code)]</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> unused_function</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">   // some unused code</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#ABB2BF;">#[warn(unused_variables)]</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> unused_variable</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">   let</span><span style="color:#E06C75;"> _unused_var</span><span style="color:#56B6C2;"> =</span><span style="color:#98C379;"> &quot;unused variable&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#ABB2BF;">#[deny(unused_imports)]</span></span>
<span class="line"><span style="color:#C678DD;"> use</span><span style="color:#E5C07B;"> std</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">collections</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">HashMap</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">#[forbid(unsafe_code)]</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> safe_function</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">   // some safe code that is not allowed to be unsafe</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在代码中使用 allow、warn、deny 和 forbid 属性可以帮助开发者更加简单高效地控制代码的输出和行为，并帮助代码更好地遵循 Rust 语言特性和最佳实践。</p><h3 id="_20-生命周期-rust-如何做基本的生命周期符号标注" tabindex="-1"><a href="https://time.geekbang.org/column/article/731096" target="_blank" rel="noreferrer">20 | 生命周期：Rust 如何做基本的生命周期符号标注？</a> <a class="header-anchor" href="#_20-生命周期-rust-如何做基本的生命周期符号标注" aria-label="Permalink to &quot;[20 | 生命周期：Rust 如何做基本的生命周期符号标注？](https://time.geekbang.org/column/article/731096)&quot;">​</a></h3><h4 id="思考题-8" tabindex="-1">思考题 <a class="header-anchor" href="#思考题-8" aria-label="Permalink to &quot;思考题&quot;">​</a></h4><p>你能说一说生命周期符号 &#39;a 放在 <code>&lt;&gt;</code> 中定义的原因和意义吗？</p><h4 id="答案-8" tabindex="-1">答案 <a class="header-anchor" href="#答案-8" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p>因为 <code>&#39;a</code> 符号本来就是一种 generic 符号。 <code>&lt;T, &#39;a&gt;</code> 中的类型参数 T 用来代表编译期空间上的分析展开， <code>&#39;a</code> 用来代表编译期时间上的分析展开。所以， <code>&#39;a</code> 放在 <code>&lt;&gt;</code> 号中是理所当然的。它们的存在都是为了给编译器提供多一些信息。</p>`,67)]))}const d=e(r,[["render",o]]);export{h as __pageData,d as default};
