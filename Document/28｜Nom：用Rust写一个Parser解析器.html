<!DOCTYPE html>
<html lang="zh" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>28 ｜ Nom：用 Rust 写一个 Parser 解析器 | 唐刚-Rust语言从入门到实战</title>
    <meta name="description" content="Rust语言从入门到实战">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/tanggang_rust/assets/style.Dmb1gw5t.css" as="style">
    <link rel="preload stylesheet" href="/tanggang_rust/vp-icons.css" as="style">
    
    <script type="module" src="/tanggang_rust/assets/app.DakBAcEX.js"></script>
    <link rel="preload" href="/tanggang_rust/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/tanggang_rust/assets/chunks/theme.BYwnybAk.js">
    <link rel="modulepreload" href="/tanggang_rust/assets/chunks/framework.D2WelYEY.js">
    <link rel="modulepreload" href="/tanggang_rust/assets/Document_28｜Nom：用Rust写一个Parser解析器.md.DtpKzSZI.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/tanggang_rust/" data-v-1168a8e4><!--[--><!--]--><!--[--><img class="VPImage logo" src="/tanggang_rust/img/buding.svg" alt data-v-8426fc1a><!--]--><span data-v-1168a8e4>Rust语言从入门到实战</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索文档"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><!----><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b3fd67f8><!----><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/00%EF%BD%9C%E5%BC%80%E7%AF%87%E8%AF%8D%EF%BD%9C%E6%8B%A5%E6%8A%B1Rust%E6%B5%AA%E6%BD%AE%EF%BC%8C%E8%BF%8E%E6%8E%A5%E6%9B%B4%E6%9E%81%E8%87%B4%E7%9A%84%E7%BC%96%E7%A8%8B%E4%BD%93%E9%AA%8C" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>00｜开篇词｜拥抱Rust浪潮，迎接更极致的编程体验</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/01%EF%BD%9C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9ARust%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>01｜快速入门：Rust中有哪些你不得不了解的基础语法？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/02%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9ARust%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E8%B5%84%E6%BA%90%E7%9A%84%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>02｜所有权（上）：Rust是如何管理程序中的资源的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/03%EF%BD%9C%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9ARust%E4%B8%AD%E5%80%9F%E7%94%A8%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E8%A7%84%E5%88%99%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>03｜所有权（下）：Rust中借用与引用的规则是怎样的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/04%EF%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E5%AF%B9%E5%8F%B7%E5%85%A5%E5%BA%A7%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%B6%E5%AE%9E%E6%B2%A1%E9%82%A3%E4%B9%88%E5%8F%AF%E6%80%95%EF%BC%81" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>04｜字符串：对号入座，字符串其实没那么可怕！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/05%EF%BD%9C%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>05｜复合类型（上）：结构体与面向对象特性</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/06%EF%BD%9C%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>06｜复合类型（下）：枚举与模式匹配</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/07%EF%BD%9C%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%EF%BC%9A%E7%BB%99Rust%E5%B0%8F%E5%8A%A9%E6%89%8B%E6%8F%90%E4%BE%9B%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>07｜类型与类型参数：给Rust小助手提供更多信息</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/08%EF%BD%9COption-T-%E4%B8%8EResult-T,E-%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>08｜Option-T-与Result-T,E-、迭代器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/09%EF%BD%9C%E5%88%9D%E8%AF%86trait%EF%BC%9A%E5%8D%8F%E8%AE%AE%E7%BA%A6%E6%9D%9F%E4%B8%8E%E8%83%BD%E5%8A%9B%E9%85%8D%E7%BD%AE" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>09｜初识trait：协议约束与能力配置</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/10%EF%BD%9C%E5%86%8D%E6%8E%A2trait%EF%BC%9A%E5%B8%A6%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84trait%E5%8F%8Atraitobject" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>10｜再探trait：带类型参数的trait及traitobject</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/11%EF%BD%9C%E5%B8%B8%E8%A7%81trait%E8%A7%A3%E6%9E%90%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81trait%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>11｜常见trait解析：标准库中的常见trait应该怎么用？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/%E7%AD%94%E7%96%91%E8%AF%BE%E5%A0%82%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9C%E7%AC%AC%E4%B8%80%E7%AB%A0Rust%E5%9F%BA%E7%A1%80%E7%AF%87%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>答疑课堂（一）｜第一章Rust基础篇思考题答案</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/12%EF%BD%9C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9A%E4%BB%8E%E6%89%80%E6%9C%89%E6%9D%83%E7%9C%8B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>12｜智能指针：从所有权看智能指针</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/13%EF%BD%9C%E7%8B%AC%E7%AB%8B%E7%8E%8B%E5%9B%BD%EF%BC%9A%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3Rust%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>13｜独立王国：初步了解Rust异步并发编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/14%EF%BD%9Ctokio%E5%AE%9E%E6%88%98%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>14｜tokio实战：编写一个网络命令行程序</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/15%EF%BD%9Ctokio%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%9C%A8%E5%A4%9A%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%93%8D%E4%BD%9C%E5%90%8C%E4%B8%80%E7%89%87%E6%95%B0%E6%8D%AE" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>15｜tokio编程：在多任务之间操作同一片数据</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/16%EF%BD%9Ctokio%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8channel%E5%9C%A8%E4%B8%8D%E5%90%8C%E4%BB%BB%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>16｜tokio编程：使用channel在不同任务间通信？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/17%EF%BD%9Ctokio%E7%BC%96%E7%A8%8B%EF%BC%9ARust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>17｜tokio编程：Rust异步编程还有哪些需要注意的点？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/18%EF%BD%9C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%9A%E9%94%99%E8%AF%AF%E7%9A%84%E6%9E%84%E5%BB%BA%E3%80%81%E4%BC%A0%E9%80%92%E5%92%8C%E5%A4%84%E7%90%86" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>18｜错误处理系统：错误的构建、传递和处理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/19%EF%BD%9CRust%E7%9A%84%E5%AE%8F%E4%BD%93%E7%B3%BB%EF%BC%9A%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A3%B0%E6%98%8E%E5%AE%8F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>19｜Rust的宏体系：为自己的项目写一个简单的声明宏</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/20%EF%BD%9C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9ARust%E5%A6%82%E4%BD%95%E5%81%9A%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AC%A6%E5%8F%B7%E6%A0%87%E6%B3%A8%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>20｜生命周期：Rust如何做基本的生命周期符号标注？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/%E7%AD%94%E7%96%91%E8%AF%BE%E5%A0%82%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0Rust%E8%BF%9B%E9%98%B6%E7%AF%87%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>答疑课堂（二）｜第二章Rust进阶篇思考题答案</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/21%EF%BD%9CWeb%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Axum%E6%A1%86%E6%9E%B6%E8%BF%9B%E8%A1%8CWeb%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>21｜Web开发（上）：如何使用Axum框架进行Web后端开发？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/22%EF%BD%9CWeb%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AATodoList%E5%BA%94%E7%94%A8%EF%BC%9F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>22｜Web开发（下）：如何实现一个TodoList应用？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/23%EF%BD%9CRust%E4%B8%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%EF%BC%9A%E7%94%A8Candle%E5%81%9A%E4%B8%80%E4%B8%AA%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>23｜Rust与大模型：用Candle做一个聊天机器人</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/24%EF%BD%9CRust%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%EF%BC%9A%E5%88%A9%E7%94%A8YOLOv8%E8%AF%86%E5%88%AB%E5%AF%B9%E8%B1%A1" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>24｜Rust图像识别：利用YOLOv8识别对象</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/25%EF%BD%9CRustGUI%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%94%A8Slint%E4%B8%BAChatbot%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>25｜RustGUI编程：用Slint为Chatbot实现一个界面</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/26%EF%BD%9CRustGUI%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%94%A8Slint%E4%B8%BAYOLOv8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>26｜RustGUI编程：用Slint为YOLOv8实现一个界面</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/27%EF%BD%9CRustBevy%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%9A%E7%94%A8300%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%81%9A%E4%B8%80%E4%B8%AA%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>27｜RustBevy游戏开发：用300行代码做一个贪吃蛇游戏</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/28%EF%BD%9CNom%EF%BC%9A%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AAParser%E8%A7%A3%E6%9E%90%E5%99%A8" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>28｜Nom：用Rust写一个Parser解析器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/29%EF%BD%9CUnsafe%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AUnsafeRust%E4%B8%AD%E9%82%A3%E4%BA%9B%E8%A2%AB%E5%B0%81%E5%8D%B0%E7%9A%84%E8%83%BD%E5%8A%9B" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>29｜Unsafe编程（上）：UnsafeRust中那些被封印的能力</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/30%EF%BD%9CUnsafe%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8Rust%E4%B8%BAPython%E5%86%99%E4%B8%80%E4%B8%AA%E6%89%A9%E5%B1%95" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>30｜Unsafe编程（下）：使用Rust为Python写一个扩展</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/%E7%AD%94%E7%96%91%E8%AF%BE%E5%A0%82%EF%BC%88%E4%B8%89%EF%BC%89%EF%BD%9C%E7%AC%AC%E4%B8%89%E7%AB%A0Rust%E5%BA%94%E7%94%A8%E7%AF%87%E6%80%9D%E8%80%83%E9%A2%98%E7%AD%94%E6%A1%88" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>答疑课堂（三）｜第三章Rust应用篇思考题答案</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/%E7%BB%93%E8%AF%BE%E6%B5%8B%E8%AF%95%EF%BD%9C%E6%9D%A5%E8%B5%B4%E4%B8%80%E5%9C%BA%E6%BB%A1%E5%88%86%E4%B9%8B%E7%BA%A6" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>结课测试｜来赴一场满分之约</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/tanggang_rust/Document/%E7%BB%93%E6%9D%9F%E8%AF%AD%EF%BD%9C%E6%9C%AA%E6%9D%A5%E8%AE%A9Rust%E5%B8%A6%E4%BD%A0%E2%80%9C%E9%94%88%E2%80%9D%E5%88%B0%E8%B5%B7%E9%A3%9E" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>结束语｜未来让Rust带你“锈”到起飞</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>⚡️文档内容大纲</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _tanggang_rust_Document_28%EF%BD%9CNom%EF%BC%9A%E7%94%A8Rust%E5%86%99%E4%B8%80%E4%B8%AAParser%E8%A7%A3%E6%9E%90%E5%99%A8" data-v-39a288b8><div><h1 id="_28-nom-用-rust-写一个-parser-解析器" tabindex="-1">28 ｜ Nom：用 Rust 写一个 Parser 解析器 <a class="header-anchor" href="#_28-nom-用-rust-写一个-parser-解析器" aria-label="Permalink to &quot;28 ｜ Nom：用 Rust 写一个 Parser 解析器&quot;">​</a></h1><p>你好，我是 Mike。今天我们来一起学习如何用 Rust 写一个 Parser 解析器。</p><p>说到解析器，非计算机科班出身的人会一脸懵，这是什么？而计算机科班出身的人会为之色变，曾经熬夜啃“龙书”的痛苦经历浮现眼前。解析器往往跟“编译原理”这个概念一起出现，谈解析器色变完全可以理解。</p><p>实际上，解析器也没那么难，并不是所有需要“解析”的地方都与编程语言相关。因此我们可以先把“编译原理”的负担给卸掉。在开发过程中，其实经常会碰到需要解析的东西，比如自定义配置文件，从网络上下载下来的一些数据文件、服务器日志文件等。这些其实不需要很深的背景知识。更加复杂一点的，比如网络协议的处理等等，这些也远没有达到一门编程语言的难度。</p><p>另一方面，虽然我们这门课属于入门级，但是对于未来的职业规划来说，如果你说你能写解析器，那面试官可能会很感兴趣。所以这节课我会从简单的示例入手，让你放下恐惧，迈上“解析”之路。</p><h2 id="解析器是什么" tabindex="-1">解析器是什么？ <a class="header-anchor" href="#解析器是什么" aria-label="Permalink to &quot;解析器是什么？&quot;">​</a></h2><p>解析器其实很简单，就是把一个字符串或字节串解析成某种类型。对应的，在 Rust 语言里就是把一个字段串解析成一个 Rust 类型。一个 Parser 其实就是一个 Rust 函数。</p><p>这个转换过程有很多种方法。</p><ol><li>最原始的是完全手撸，一个字符一个字符吞入解析。</li><li>对一些简单情况，直接使用 String 类型中的 find、split、replace 等函数就可以。</li><li>用正则表达式能够解析大部分种类的文本。</li><li>还可以用一些工具或库帮助解析，比如 Lex、Yacc、LalrPop、Nom、Pest 等。</li><li>Rust 语言的宏也能用来设计 DSL，能实现对 DSL 文本的解析。</li></ol><p>这节课我们只关注第 4 点。在所有辅助解析的工具或库里，我们只关心 Rust 生态辅助解析的库。</p><h2 id="rust-生态中主流的解析工具" tabindex="-1">Rust 生态中主流的解析工具 <a class="header-anchor" href="#rust-生态中主流的解析工具" aria-label="Permalink to &quot;Rust 生态中主流的解析工具&quot;">​</a></h2><p>目前 Rust 生态中已经有几个解析库用得比较广泛，我们分别来了解下。</p><ul><li><a href="https://crates.io/crates/lalrpop" target="_blank" rel="noreferrer">LalrPop</a> 类似于 Yacc，用定义匹配规则和对应的行为方式来写解析器。</li><li><a href="https://crates.io/crates/pest" target="_blank" rel="noreferrer">Pest</a> 使用解析表达式语法（Parsing Expression Grammar，PEG）来定义解析规则，PEG 已经形成了一个成熟的标准，各种语言都有相关的实现。</li><li>Nom 是一个解析器组合子（Parser-Combinator）库，用函数组合的方式来写规则。一个 Parser 就是一个函数，接收一个输入，返回一个结果。而组合子 combinator 也是一个函数，用来接收多个 Parser 函数作为输入，把这些小的 Parser 组合在一起，形成一个大的 Parser。这个过程可以无限叠加。</li></ul><h2 id="nom-库介绍" tabindex="-1">Nom 库介绍 <a class="header-anchor" href="#nom-库介绍" aria-label="Permalink to &quot;Nom 库介绍&quot;">​</a></h2><p>这节课我们选用 Nom 库来讲解如何快速写出一个解析器，目前（2023 年 12 月）Nom 库的版本为 v7.1。选择 Nom 的原因是，它可以用来解析几乎一切东西，比如文本协议、二进制文件、流数据、视频编码数据、音频编码数据，甚至是一门完整功能的编程语言。</p><p>Nom 的显著特性在安全解析、便捷的解析过程中的错误处理和尽可能的零拷贝上。因此用 Nom 解析库写的代码是非常高效的，甚至比你用 C 语言手撸一个解析器更高效，这里有一些 <a href="https://github.com/rust-bakery/parser_benchmarks" target="_blank" rel="noreferrer">评测</a> 你可以参考。Nom 能够做到这种程度主要是因为站在了 Rust 的肩膀上。</p><p>解析器组合子是一种解析方法，这种方法不同于 PEG 通过写单独的语法描述文件的方式进行解析。Nom 的 slogan 是“nom, eating data byte by byte”，也就是一个字节一个字节地吞，顺序解析。</p><p>使用 Nom 你可以写特定目的的小函数，比如获取 5 个字节、识别单词 HTTP 等，然后用有意义的模式把它们组装起来，比如识别 <code>&#39;HTTP&#39;</code>，然后是一个空格、一个版本号，也就是 <code>&#39;HTTP 1.1&#39;</code> 这种形式。这样写出的代码就非常小，容易起步。并且这种形式明显适用于流模式，比如网络传输的数据，一次可能拿不完，使用 Nom 能够边取数据边解析。</p><p>解析器组合子思路有 5 个优势。</p><ul><li>解析器很小，很容易写。</li><li>解析器的组件非常容易重用。</li><li>解析器的组件非常容易用单元测试进行独立测试。</li><li>解析器组合的代码看起来接近于你要解析的数据结构，非常直白。</li><li>你可以针对你当前的特定数据，构建部分解析器，而不用关心其他数据部分。</li></ul><h3 id="nom-的工作方式" tabindex="-1">Nom 的工作方式 <a class="header-anchor" href="#nom-的工作方式" aria-label="Permalink to &quot;Nom 的工作方式&quot;">​</a></h3><p>Nom 的解析器基本工作方式很简单，就是读取输入数据流，比如字符串，返回 <code>(rest, output)</code> 这样一个 tuple，rest 就是没有解析到的字符串的剩余部分，output 就是解析出来的目标类型。很多时候，这个返回结果就是(&amp;str, &amp;str)。解析过程中，可以处理解析错误。</p><p><img src="/tanggang_rust/assets/3dc2525bf7768d62b0efaaa0332d0e2a.cn7sIhTn.jpg" alt=""></p><h3 id="基本解析器和组合子" tabindex="-1">基本解析器和组合子 <a class="header-anchor" href="#基本解析器和组合子" aria-label="Permalink to &quot;基本解析器和组合子&quot;">​</a></h3><p>在 Nom 中，一个 Parser 其实就是一个函数。Nom 提供了一些最底层的 Parser。相当于构建房屋的砖块，我们掌握了这些砖块后，就可以把这些砖块组合使用，像乐高积木，一层层越搭越高。</p><p>这里我们列举一些常用的解析器，案例基本上都是对字符串的解析。</p><h4 id="tag" tabindex="-1">Tag <a class="header-anchor" href="#tag" aria-label="Permalink to &quot;Tag&quot;">​</a></h4><p>tag 非常常用，用来指代一个确定性的字符串，比如 “hello”。</p><ul><li><a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.tag.html" target="_blank" rel="noreferrer">tag</a>：识别一个确定性的字符串。</li><li><a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.tag_no_case.html" target="_blank" rel="noreferrer">tag_no_case</a>：识别一个确定性的字符串，忽略大小写。</li></ul><h4 id="基本类别解析器" tabindex="-1">基本类别解析器 <a class="header-anchor" href="#基本类别解析器" aria-label="Permalink to &quot;基本类别解析器&quot;">​</a></h4><p>下面是 Nom 提供的用来识别字符的基本解析器，可以看到，都是我们熟知的解析器。</p><ul><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha0.html" target="_blank" rel="noreferrer">alpha0</a>：识别 a-z, A-Z 中的字符 0 个或多个。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha1.html" target="_blank" rel="noreferrer">alpha1</a>：识别 a-z, A-Z 中的字符 1 个或多个（至少 1 个）。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric0.html" target="_blank" rel="noreferrer">alphanumeric0</a>：识别 0-9, a-z, A-Z 中的字符 0 个或多个。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric1.html" target="_blank" rel="noreferrer">alphanumeric1</a>：识别 0-9, a-z, A-Z 中的字符 1 个或多个（至少 1 个）。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit0.html" target="_blank" rel="noreferrer">digit0</a>：识别 0-9 中的字符 0 个或多个。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html" target="_blank" rel="noreferrer">digit1</a>：识别 0-9 中的字符 1 个或多个（至少 1 个）。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.hex_digit0.html" target="_blank" rel="noreferrer">hex_digit0</a>：识别 0-9, A-F, a-f 中的字符 0 个或多个。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.hex_digit1.html" target="_blank" rel="noreferrer">hex_digit1</a>：识别 0-9, A-F, a-f 中的字符 1 个或多个（至少 1 个）。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.space0.html" target="_blank" rel="noreferrer">space0</a>：识别 空格和 tab 符 \t 0 个或多个。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.space1.html" target="_blank" rel="noreferrer">space1</a>：识别 空格和 tab 符 \t 0 个或多个（至少 1 个）。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.multispace0.html" target="_blank" rel="noreferrer">multispace0</a>：识别 空格、tab 符 \t 、回车符 \r、换行符\n， 0 个或多个。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.multispace1.html" target="_blank" rel="noreferrer">multispace1</a>：识别 空格、tab 符 \t 、回车符 \r、换行符\n， 1 个或多个（至少 1 个）。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.tab.html" target="_blank" rel="noreferrer">tab</a>：识别确定的制表符 \t。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.newline.html" target="_blank" rel="noreferrer">newline</a>：识别确定的换行符 \n。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.line_ending.html" target="_blank" rel="noreferrer">line_ending</a>：识别 ‘\n’ 和‘\r\n’。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.not_line_ending.html" target="_blank" rel="noreferrer">not_line_ending</a>：识别 ‘\n’ 和‘\r\n’之外的其他字符（串）。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.one_of.html" target="_blank" rel="noreferrer">one_of</a>：识别给定的字符集合中的一个。</li><li><a href="https://docs.rs/nom/latest/nom/character/complete/fn.none_of.html" target="_blank" rel="noreferrer">none_of</a>：识别给定的字符集合之外的字符。</li></ul><p>完整的列表请看这里： <a href="https://docs.rs/nom/latest/nom/character/complete/index.html" target="_blank" rel="noreferrer">https://docs.rs/nom/latest/nom/character/complete/index.html</a></p><h4 id="基本组合子" tabindex="-1">基本组合子 <a class="header-anchor" href="#基本组合子" aria-label="Permalink to &quot;基本组合子&quot;">​</a></h4><ul><li><a href="https://docs.rs/nom/latest/nom/branch/fn.alt.html" target="_blank" rel="noreferrer">alt</a>：Try a list of parsers and return the result of the first successful one 或组合子，满足其中的一个解析器就可成功返回。</li><li><a href="https://docs.rs/nom/latest/nom/sequence/fn.tuple.html" target="_blank" rel="noreferrer">tuple</a>：和组合子，并且按顺序执行解析器，并返回它们的值为一个 tuple。</li><li><a href="https://docs.rs/nom/latest/nom/sequence/fn.delimited.html" target="_blank" rel="noreferrer">delimited</a>：解析左分界符目标信息右分界符这种格式，比如 <code>&quot;{ ... }&quot;</code>，返回目标信息。</li><li><a href="https://docs.rs/nom/latest/nom/sequence/fn.pair.html" target="_blank" rel="noreferrer">pair</a>：tuple 的两元素版本，返回一个二个元素的 tutple。</li><li><a href="https://docs.rs/nom/latest/nom/sequence/fn.separated_pair.html" target="_blank" rel="noreferrer">separated_pair</a>：解析目标信息分隔符目标信息这种格式，比如 <code>&quot;1,2&quot;</code> 这种，返回一个二个元素的 tutple。</li><li><a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while_m_n.html" target="_blank" rel="noreferrer">take_while_m_n</a>：解析最少 m 个，最多 n 个字符，这些字符要符合给定的条件。</li></ul><p>更多 Nom 中的解析器和组合子的信息请查阅 <a href="https://docs.rs/nom/latest/nom/index.html" target="_blank" rel="noreferrer">Nom 的 API</a>。</p><h2 id="nom-实战" tabindex="-1">Nom 实战 <a class="header-anchor" href="#nom-实战" aria-label="Permalink to &quot;Nom 实战&quot;">​</a></h2><p>我们从最简单的解析器开始。</p><h3 id="_0-号解析器" tabindex="-1">0 号解析器 <a class="header-anchor" href="#_0-号解析器" aria-label="Permalink to &quot;0 号解析器&quot;">​</a></h3><p>0 号解析器就相当于整数的 0，这是一个什么也干不了的解析器。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> std</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">error</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">Error</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">pub</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> do_nothing_parser</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;&amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">, &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="color:#E5C07B;">    Ok</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&quot;&quot;</span><span style="color:#ABB2BF;">))</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">Result</span><span style="color:#ABB2BF;">&lt;(), </span><span style="color:#E5C07B;">Box</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#C678DD;">dyn</span><span style="color:#E5C07B;"> Error</span><span style="color:#ABB2BF;">&gt;&gt; {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">remaining_input</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">output</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> do_nothing_parser</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;abcdefg&quot;</span><span style="color:#ABB2BF;">)?;</span></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">remaining_input</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&quot;abcdefg&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">output</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&quot;&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;">    Ok</span><span style="color:#ABB2BF;">(())</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面的 <code>do_nothing_parser()</code> 函数就是一个 Nom 的解析器，对，就是一个普通的 Rust 函数，它接收一个 &amp;str 参数，返回一个 <code>IResult&lt;&amp;str, &amp;str&gt;，IResult&lt;I, O&gt;</code> 是 Nom 定义的解析器的标准返回类型。你可以看一下它的 <a href="https://docs.rs/nom/latest/nom/type.IResult.html" target="_blank" rel="noreferrer">定义</a>。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">pub</span><span style="color:#C678DD;"> type</span><span style="color:#E5C07B;"> IResult</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">I</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">O</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">E</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> Error</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">I</span><span style="color:#ABB2BF;">&gt;&gt; </span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;"> Result</span><span style="color:#ABB2BF;">&lt;(</span><span style="color:#E5C07B;">I</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">O</span><span style="color:#ABB2BF;">), </span><span style="color:#E5C07B;">Err</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">E</span><span style="color:#ABB2BF;">&gt;&gt;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>可以看到，正确返回情况下，它的返回内容是 <code>(I, O)</code>，一个元组，元组第一个元素是剩下的未解析的输入流部分，第二个元素是解析出的内容。这正好对应 <code>do_nothing_parser()</code> 的返回内容 <code>(input, &quot;&quot;)</code>。这里是原样返回，不做任何处理。</p><p>注意， <code>E = Error&lt;I&gt;</code> 这种写法是类型参数的默认类型，请回顾课程 <a href="https://time.geekbang.org/column/article/724776?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noreferrer">第 10 讲</a> 找到相关知识点。</p><p>看起来这个解析器没有啥作用，但不可否认，它让我们直观感受了 Nom 中的 parser 是个什么东西，我们已经有了基本模板。</p><h3 id="_1-号解析器" tabindex="-1">1 号解析器 <a class="header-anchor" href="#_1-号解析器" aria-label="Permalink to &quot;1 号解析器&quot;">​</a></h3><p>这次我们必须要做点什么事情了，那就把 <code>&quot;abcedfg&quot;</code> 的前三个字符识别出来。我们需要用到 tag 解析器。代码如下：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">pub</span><span style="color:#C678DD;"> use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">bytes</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">complete</span><span style="color:#ABB2BF;">::tag;</span></span>
<span class="line"><span style="color:#C678DD;">pub</span><span style="color:#C678DD;"> use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> std</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">error</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">Error</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> parse_input</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;&amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">, &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="color:#61AFEF;">    tag</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;abc&quot;</span><span style="color:#ABB2BF;">)(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">Result</span><span style="color:#ABB2BF;">&lt;(), </span><span style="color:#E5C07B;">Box</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#C678DD;">dyn</span><span style="color:#E5C07B;"> Error</span><span style="color:#ABB2BF;">&gt;&gt; {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">leftover_input</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">output</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> parse_input</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;abcdefg&quot;</span><span style="color:#ABB2BF;">)?;</span></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">leftover_input</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&quot;defg&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">output</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&quot;abc&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF;">    assert!</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">parse_input</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;defdefg&quot;</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">is_err</span><span style="color:#ABB2BF;">());</span></span>
<span class="line"><span style="color:#E5C07B;">    Ok</span><span style="color:#ABB2BF;">(())</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在这个例子里， <code>tag(&quot;abc&quot;)</code> 的返回值是一个 parser，然后这个 parser 再接收 input 的输入，并返回 <code>IResult&lt;&amp;str, &amp;str&gt;</code>。前面的我们看到，tag 识别固定的字符串/字节串。</p><p>tag 实际返回一个闭包，你可以看一下它的定义。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">pub</span><span style="color:#C678DD;"> fn</span><span style="color:#61AFEF;"> tag</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">T</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Error</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">ParseError</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">&gt;&gt;(</span></span>
<span class="line"><span style="color:#E06C75;">    tag</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">T</span></span>
<span class="line"><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#C678DD;">impl</span><span style="color:#61AFEF;"> Fn</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Error</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;">where</span></span>
<span class="line"><span style="color:#E5C07B;">    Input</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">InputTake</span><span style="color:#ABB2BF;"> + </span><span style="color:#E5C07B;">Compare</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">T</span><span style="color:#ABB2BF;">&gt;,</span></span>
<span class="line"><span style="color:#E5C07B;">    T</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">InputLength</span><span style="color:#ABB2BF;"> + </span><span style="color:#E5C07B;">Clone</span><span style="color:#ABB2BF;">,</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>也就是返回下面这行内容。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">impl</span><span style="color:#61AFEF;"> Fn</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Input</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Error</span><span style="color:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里这个 Fn 就是用于描述闭包的 trait，你可以回顾一下课程 <a href="https://time.geekbang.org/column/article/724942" target="_blank" rel="noreferrer">第 11 讲</a> 中关于它的内容。</p><p>这个示例里 <code>parse_input(&quot;abcdefg&quot;)?</code> 这个解析器会返回 <code>(&quot;defg&quot;, &quot;abc&quot;)</code>，也就是把 <code>&quot;abc&quot;</code> 解析出来了，并返回了剩下的 <code>&quot;defg&quot;</code>。而如果在待解析输入中找不到目标 pattern，那么就会返回 Err。</p><h3 id="解析一个坐标" tabindex="-1">解析一个坐标 <a class="header-anchor" href="#解析一个坐标" aria-label="Permalink to &quot;解析一个坐标&quot;">​</a></h3><p>下面我们再加大难度，解析一个坐标，也就是从 <code>&quot;(x, y)&quot;</code> 这种形式中解析出 x 和 y 两个数字来。</p><p>代码如下：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> std</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">error</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">Error</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">bytes</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">complete</span><span style="color:#ABB2BF;">::tag;</span></span>
<span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">sequence</span><span style="color:#ABB2BF;">::{separated_pair, delimited};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">#[derive(</span><span style="color:#E5C07B;">Debug</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">PartialEq</span><span style="color:#ABB2BF;">)]</span></span>
<span class="line"><span style="color:#C678DD;">pub</span><span style="color:#C678DD;"> struct</span><span style="color:#E5C07B;"> Coordinate</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">  pub</span><span style="color:#E06C75;"> x</span><span style="color:#ABB2BF;">:   </span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#C678DD;">  pub</span><span style="color:#E06C75;"> y</span><span style="color:#ABB2BF;">:   </span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">character</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">complete</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 解析 &quot;x, y&quot; 这种格式</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> parse_integer_pair</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;&amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">, (</span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">)&gt; {</span></span>
<span class="line"><span style="color:#61AFEF;">    separated_pair</span><span style="color:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#E5C07B;">        i32</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#61AFEF;">        tag</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;, &quot;</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#E5C07B;">        i32</span></span>
<span class="line"><span style="color:#ABB2BF;">    )(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 解析 &quot;( ... )&quot; 这种格式</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> parse_coordinate</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;&amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Coordinate</span><span style="color:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">remaining</span><span style="color:#ABB2BF;">, (</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;">)) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> delimited</span><span style="color:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#61AFEF;">        tag</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;(&quot;</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#E06C75;">        parse_integer_pair</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#61AFEF;">        tag</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;)&quot;</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">    )(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)?;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">    Ok</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;">remaining</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Coordinate</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;">}))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() -&gt; </span><span style="color:#E5C07B;">Result</span><span style="color:#ABB2BF;">&lt;(), </span><span style="color:#E5C07B;">Box</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#C678DD;">dyn</span><span style="color:#E5C07B;"> Error</span><span style="color:#ABB2BF;">&gt;&gt; {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">_</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">parsed</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> parse_coordinate</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;(3, 5)&quot;</span><span style="color:#ABB2BF;">)?;</span></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">parsed</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Coordinate</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">5</span><span style="color:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">_</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">parsed</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> parse_coordinate</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;(2, -4)&quot;</span><span style="color:#ABB2BF;">)?;</span></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">parsed</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Coordinate</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;">: -</span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    // 用nom，可以方便规范地处理解析失败的情况</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> parsing_error</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> parse_coordinate</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;(3,)&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">    assert!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">parsing_error</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">is_err</span><span style="color:#ABB2BF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> parsing_error</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> parse_coordinate</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;(,3)&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">    assert!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">parsing_error</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">is_err</span><span style="color:#ABB2BF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#E06C75;"> parsing_error</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> parse_coordinate</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Ferris&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">    assert!</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">parsing_error</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">is_err</span><span style="color:#ABB2BF;">());</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">    Ok</span><span style="color:#ABB2BF;">(())</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br></div></div><p>我们从 <code>parse_coordinate() parser</code> 看起。首先遇到的是 delimited 这个 combinator，它的作用我们查一下上面的表格，是解析左分界符目标信息右分界符这种格式，返回目标信息，也就是解析 <code>(xxx), &lt;xxx&gt;, {xxx}</code> 这种前后配对边界符的 pattern，正好可以用来识别我们这个 <code>(x, y)</code>，我们把 <code>&quot;(x, y)&quot;</code> 第一步分解成 <code>&quot;(&quot;, &quot;x, y&quot;, &quot;)&quot;</code> 三部分，用 delimited 来处理。同样的，它也返回一个解析器闭包。</p><p>然后，对于中间的这部分 <code>&quot;x, y&quot;</code>，我们用 <code>parse_integer_pair()</code> 这个 parser 来处理。继续看这个函数，它里面用到了 <code>separated_pair</code> 这个 combinator。查一下上面的表，你会发现它是用来处理左目标信息分隔符右目标信息这种 pattern 的，刚好能处理我们的 <code>&quot;x, y&quot;</code>。中间那个分隔符就用一个 <code>tag(&quot;, &quot;)</code> 表示，两侧是 i32 这个 parser。注意，这里这个 <a href="https://docs.rs/nom/latest/nom/character/complete/fn.i32.html" target="_blank" rel="noreferrer">i32</a> 是代码中引入的。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">character</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">complete</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">i32</span><span style="color:#ABB2BF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>不是 Rust std 中的那个 i32，它实际是 Nom 中提供的一个 parser，用来把字符串解析成 std 中的 i32 数字。 <code>separated_pair</code> 也返回一个解析器闭包。可以看到，返回的闭包调用形式和 delimited 是一样的。其实整个 Nom 解析器的签名都是固定的，可以以这种方式无限搭积木。</p><p><code>parse_integer_pair</code> 就返回了 `(x, y) 两个 i32 数字组成的元组类型，最后再包成 Coordinate 结构体类型返回。整个任务就结束了。</p><p>可以看到，这实际就是标准的 <strong>递归下降</strong> 解析方法。先识别大 pattern，分割，一层层解析小 pattern，直到解析到最小单元为止，再组装成需要的输出类型，从函数中一层层返回。整个过程就是普通的 Rust 函数栈调用过程。</p><h3 id="解析-16-进制色彩编码" tabindex="-1">解析 16 进制色彩编码 <a class="header-anchor" href="#解析-16-进制色彩编码" aria-label="Permalink to &quot;解析 16 进制色彩编码&quot;">​</a></h3><p>下面我们继续看一个示例：解析网页上的色彩格式 #2F14DF。</p><p>对于这样比较简单的问题，手动用 String 的方法分割当然可以，用正则表达式也可以。这里我们来研究用 Nom 怎样做。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">use</span><span style="color:#E5C07B;"> nom</span><span style="color:#ABB2BF;">::{</span></span>
<span class="line"><span style="color:#E5C07B;">    bytes</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">complete</span><span style="color:#ABB2BF;">::{tag, take_while_m_n},</span></span>
<span class="line"><span style="color:#E5C07B;">    combinator</span><span style="color:#ABB2BF;">::map_res,</span></span>
<span class="line"><span style="color:#E5C07B;">    sequence</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">Tuple</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E5C07B;">    IResult</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">#[derive(</span><span style="color:#E5C07B;">Debug</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">PartialEq</span><span style="color:#ABB2BF;">)]</span></span>
<span class="line"><span style="color:#C678DD;">pub</span><span style="color:#C678DD;"> struct</span><span style="color:#E5C07B;"> Color</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">    pub</span><span style="color:#E06C75;"> red</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">u8</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#C678DD;">    pub</span><span style="color:#E06C75;"> green</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">u8</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#C678DD;">    pub</span><span style="color:#E06C75;"> blue</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">u8</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> from_hex</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">Result</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#E5C07B;">u8</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">std</span><span style="color:#ABB2BF;">::</span><span style="color:#E06C75;">num</span><span style="color:#ABB2BF;">::</span><span style="color:#E5C07B;">ParseIntError</span><span style="color:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="color:#E5C07B;">    u8</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">from_str_radix</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">16</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> is_hex_digit</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">c</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">char</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">bool</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E06C75;">    c</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">is_digit</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">16</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> hex_primary</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;&amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">u8</span><span style="color:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="color:#61AFEF;">    map_res</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">take_while_m_n</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">is_hex_digit</span><span style="color:#ABB2BF;">), </span><span style="color:#E06C75;">from_hex</span><span style="color:#ABB2BF;">)(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> hex_color</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">: &amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">) -&gt; </span><span style="color:#E5C07B;">IResult</span><span style="color:#ABB2BF;">&lt;&amp;</span><span style="color:#E5C07B;">str</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Color</span><span style="color:#ABB2BF;">&gt; {</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">_</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> tag</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;#&quot;</span><span style="color:#ABB2BF;">)(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)?;</span></span>
<span class="line"><span style="color:#C678DD;">    let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, (</span><span style="color:#E06C75;">red</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">green</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">blue</span><span style="color:#ABB2BF;">)) </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">parse</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)?;</span></span>
<span class="line"><span style="color:#E5C07B;">    Ok</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Color</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">red</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">green</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">blue</span><span style="color:#ABB2BF;"> }))</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">#[test]</span></span>
<span class="line"><span style="color:#C678DD;">fn</span><span style="color:#61AFEF;"> parse_color</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#61AFEF;">    assert_eq!</span><span style="color:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#61AFEF;">        hex_color</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;#2F14DF&quot;</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#E5C07B;">        Ok</span><span style="color:#ABB2BF;">((</span></span>
<span class="line"><span style="color:#98C379;">            &quot;&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E5C07B;">            Color</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E06C75;">                red</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">47</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">                green</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">20</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">                blue</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">223</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">            }</span></span>
<span class="line"><span style="color:#ABB2BF;">        ))</span></span>
<span class="line"><span style="color:#ABB2BF;">    );</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><p>执行 <code>cargo test</code>，输出 ：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E06C75;">running</span><span style="color:#D19A66;"> 1</span><span style="color:#E06C75;"> test</span></span>
<span class="line"><span style="color:#E06C75;">test</span><span style="color:#E06C75;"> parse_color</span><span style="color:#ABB2BF;"> ... </span><span style="color:#E06C75;">ok</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E06C75;">test</span><span style="color:#E06C75;"> result</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">ok</span><span style="color:#ABB2BF;">. </span><span style="color:#D19A66;">1</span><span style="color:#E06C75;"> passed</span><span style="color:#ABB2BF;">; </span><span style="color:#D19A66;">0</span><span style="color:#E06C75;"> failed</span><span style="color:#ABB2BF;">; </span><span style="color:#D19A66;">0</span><span style="color:#E06C75;"> ignored</span><span style="color:#ABB2BF;">; </span><span style="color:#D19A66;">0</span><span style="color:#E06C75;"> measured</span><span style="color:#ABB2BF;">; </span><span style="color:#D19A66;">0</span><span style="color:#E06C75;"> filtered</span><span style="color:#E06C75;"> out</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">finished</span><span style="color:#C678DD;"> in</span><span style="color:#D19A66;"> 0.</span><span style="color:#ABB2BF;">00s</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们来详细解释这个文件。</p><p>代码从 <code>hex_color</code> 入手，输入就是 <code>&quot;#2F14DF&quot;</code> 这个字符串。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">_</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">=</span><span style="color:#61AFEF;"> tag</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;#&quot;</span><span style="color:#ABB2BF;">)(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)?;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这句执行完，返回的 input 变成 <code>&quot;2F14DF&quot;</code>。</p><p>接下来就要分析三个 16 进制数字，两个字符一组。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">parse</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)?;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们在元组上直接调用了 <code>.parse()</code> 函数。这是什么神奇的用法？别慌，你在 std 标准库文档里面肯定找不到，实现在 <a href="https://docs.rs/nom/latest/nom/sequence/trait.Tuple.html#tymethod.parse" target="_blank" rel="noreferrer">这里</a>。它将常用的元组变成了 parser。但是这样的实现需要手动调用一下 <code>.parse()</code> 函数来执行解析。</p><p>这里我们意图就是把颜色解析成独立的三个元素，每种元素是一个 16 进制数，这个 16 进制数进一步用 <code>hex_primary</code> 来解析。我们再来看 <code>hex_primary</code> 的实现。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">map_res</span><span style="color:#ABB2BF;">(</span></span>
<span class="line"><span style="color:#61AFEF;">    take_while_m_n</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">is_hex_digit</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#E06C75;">    from_hex</span></span>
<span class="line"><span style="color:#ABB2BF;">  )(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其中，代码第二行表示在 input 中一次取 2 个字符（前面两个参数 2，2，表示返回不多于 2 个，不少于 2 个，因此就是等于 2 个），取出每个字符的时候，都要判断是否是 16 进制数字。是的话才取，不是的话就会返回 Err。</p><p><code>map_res</code> 的意思是，对 <code>take_while_m_n parser</code> 返回的结果应用一个后面提供的函数，这里就是 <code>from_hex</code>，它的目的是把两个 16 进制的字符组成的字符串转换成 10 进制数字类型，这里就是 u8 类型。因此 <code>hex_primary</code> 函数返回的结果是 <code>IResult&lt;&amp;str, u8&gt;</code>。 <code>u8::from_str_radix(input, 16)</code> 是 Rust std 库中的 u8 类型的自带方法，16 表示 16 进制。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">  let</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, (</span><span style="color:#E06C75;">red</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">green</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">blue</span><span style="color:#ABB2BF;">)) </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">hex_primary</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">parse</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">)?;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>因此这一行，正常返回后，input 就为 <code>&quot;&quot;</code> 了， <code>(red, green, blue)</code> 这三个是 u8 类型的三元素 tuple，实际这里相当于定义了 red、green、blue 三个变量。</p><p>然后下面一行，就组装成 Color 对象返回了，目标完成。</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">Ok</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;">input</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">Color</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">red</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">green</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">blue</span><span style="color:#ABB2BF;"> }))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="更多示例" tabindex="-1">更多示例 <a class="header-anchor" href="#更多示例" aria-label="Permalink to &quot;更多示例&quot;">​</a></h3><p>前面我们说过，Nom 非常强大，可应用领域非常广泛，这里有一些链接，你有兴趣的话，可以继续深入研究。</p><ul><li>解析 HTTP2 协议： <a href="https://github.com/sozu-proxy/sozu/blob/main/lib/src/protocol/h2/parser.rs" target="_blank" rel="noreferrer">https://github.com/sozu-proxy/sozu/blob/main/lib/src/protocol/h2/parser.rs</a></li><li>解析 flv 文件： <a href="https://github.com/rust-av/flavors/blob/master/src/parser.rs" target="_blank" rel="noreferrer">https://github.com/rust-av/flavors/blob/master/src/parser.rs</a>，你还可以对照 C 实现体会 Nom 的厉害之处： <a href="https://github.com/FFmpeg/FFmpeg/blob/master/libavformat/flvdec.c" target="_blank" rel="noreferrer">https://github.com/FFmpeg/FFmpeg/blob/master/libavformat/flvdec.c</a>。</li><li>解析 Python 代码： <a href="https://github.com/progval/rust-python-parser" target="_blank" rel="noreferrer">https://github.com/progval/rust-python-parser</a></li><li>自己写一个语言： <a href="https://github.com/Rydgel/monkey-rust" target="_blank" rel="noreferrer">https://github.com/Rydgel/monkey-rust</a></li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>这节课我们学习了如何用 Nom 解决解析器任务。在计算机领域，需要解析的场景随处可见，以前的 lexer、yacc 等套路其实已经过时了，Rust 的 Nom 之类的工具才是业界最新的成果，你掌握了 Nom 等工具，就能让这类工作轻松自如。</p><p>我们需要理解 Nom 这类解析器库背后的 <strong>解析器-组合子</strong> 思想，它是一种通用的解决复杂问题的构建方法，也就是递归下降分解问题，从上到下分割任务，直到问题可解决为止。然后先解决基本的小问题，再把这些成果像砖块那样组合起来，于是便能够解决复杂的系统问题。</p><p>可以看到，Nom 的学习门槛其实并不高，其中很关键的一点是学完一部分就能应用一部分，不像其他有些框架，必须整体学完后才能应用。一旦你通过一定的时间掌握了 Nom 的基本武器零件后，就会收获到一项强大的新技能，能够让你在以后的工作中快速升级，解决你以前不敢去解决的问题。</p><p>这节课你应该也能感受到 Rust 打下的扎实基础（安全编程、高性能等），Rust 生态已经构建出强大框架和工具，这些框架和工具能够让我们达到前所未有的生产力水平，已经完全不输于甚至超过其他编程语言了。</p><p>这节课所有可运行代码在这里： <a href="https://github.com/miketang84/jikeshijian/tree/master/28-nom" target="_blank" rel="noreferrer">https://github.com/miketang84/jikeshijian/tree/master/28-nom</a></p><h2 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h2><p>请尝试用 Nom 解析一个简单版本的 CSV 格式文件。欢迎你把你解析的内容分享出来，我们一起看一看，如果你觉得这节课对你有帮助的话，也欢迎你分享给其他朋友，我们下节课再见！</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><div class="edit-link" data-v-e257564d><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/muyaCode/FrontEndLearnNotes/edit/main/docs/Document/28｜Nom：用Rust写一个Parser解析器.md" target="_blank" rel="noreferrer" data-v-e257564d><!--[--><span class="vpi-square-pen edit-link-icon" data-v-e257564d></span> 在 GitHub 上编辑此页<!--]--></a></div><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-e98dd255>上次更新：: <time datetime="2025-02-28T18:19:24.000Z" data-v-e98dd255></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/tanggang_rust/Document/27%EF%BD%9CRustBevy%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%9A%E7%94%A8300%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%81%9A%E4%B8%80%E4%B8%AA%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>上一篇</span><span class="title" data-v-e257564d>27｜RustBevy游戏开发：用300行代码做一个贪吃蛇游戏</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/tanggang_rust/Document/29%EF%BD%9CUnsafe%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AUnsafeRust%E4%B8%AD%E9%82%A3%E4%BA%9B%E8%A2%AB%E5%B0%81%E5%8D%B0%E7%9A%84%E8%83%BD%E5%8A%9B" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>下一篇</span><span class="title" data-v-e257564d>29｜Unsafe编程（上）：UnsafeRust中那些被封印的能力</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><p class="message" data-v-e315a0ad>Released under the MIT License.</p><p class="copyright" data-v-e315a0ad>Copyright © 2025  MuYa</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"document_00｜开篇词｜拥抱rust浪潮，迎接更极致的编程体验.md\":\"Bx6ruBRE\",\"document_01｜快速入门：rust中有哪些你不得不了解的基础语法？.md\":\"YEQ1UjRq\",\"document_02｜所有权（上）：rust是如何管理程序中的资源的？.md\":\"Bvb116GB\",\"document_03｜所有权（下）：rust中借用与引用的规则是怎样的？.md\":\"BJwhWwWd\",\"document_04｜字符串：对号入座，字符串其实没那么可怕！.md\":\"Bv5l_4z9\",\"document_05｜复合类型（上）：结构体与面向对象特性.md\":\"CITkKTJg\",\"document_06｜复合类型（下）：枚举与模式匹配.md\":\"Ct8Xedp7\",\"document_07｜类型与类型参数：给rust小助手提供更多信息.md\":\"EbjW2AkC\",\"document_08｜option-t-与result-t_e-、迭代器.md\":\"BNKn_0uw\",\"document_09｜初识trait：协议约束与能力配置.md\":\"llurKKcW\",\"document_10｜再探trait：带类型参数的trait及traitobject.md\":\"CMwHA5A-\",\"document_11｜常见trait解析：标准库中的常见trait应该怎么用？.md\":\"BGa5CpQf\",\"document_12｜智能指针：从所有权看智能指针.md\":\"Cxvwfxu6\",\"document_13｜独立王国：初步了解rust异步并发编程.md\":\"DSU5sdFT\",\"document_14｜tokio实战：编写一个网络命令行程序.md\":\"C1JeQOSl\",\"document_15｜tokio编程：在多任务之间操作同一片数据.md\":\"Bwzc0tpF\",\"document_16｜tokio编程：使用channel在不同任务间通信？.md\":\"DKrhaVoh\",\"document_17｜tokio编程：rust异步编程还有哪些需要注意的点？.md\":\"CmxLkup0\",\"document_18｜错误处理系统：错误的构建、传递和处理.md\":\"BWw-vDDL\",\"document_19｜rust的宏体系：为自己的项目写一个简单的声明宏.md\":\"DXluFKAD\",\"document_20｜生命周期：rust如何做基本的生命周期符号标注？.md\":\"Bt1xgIs6\",\"document_21｜web开发（上）：如何使用axum框架进行web后端开发？.md\":\"DXd_p46T\",\"document_22｜web开发（下）：如何实现一个todolist应用？.md\":\"Bi1r-Ulj\",\"document_23｜rust与大模型：用candle做一个聊天机器人.md\":\"CDaEmFi3\",\"document_24｜rust图像识别：利用yolov8识别对象.md\":\"CMFa5k75\",\"document_25｜rustgui编程：用slint为chatbot实现一个界面.md\":\"CSQiE64f\",\"document_26｜rustgui编程：用slint为yolov8实现一个界面.md\":\"8_AGledo\",\"document_27｜rustbevy游戏开发：用300行代码做一个贪吃蛇游戏.md\":\"DcZ-wJin\",\"document_28｜nom：用rust写一个parser解析器.md\":\"DtpKzSZI\",\"document_29｜unsafe编程（上）：unsaferust中那些被封印的能力.md\":\"DkGls-cm\",\"document_30｜unsafe编程（下）：使用rust为python写一个扩展.md\":\"tPXz85a6\",\"document_答疑课堂（一）｜第一章rust基础篇思考题答案.md\":\"CC_0mUbW\",\"document_答疑课堂（三）｜第三章rust应用篇思考题答案.md\":\"He3Na2GY\",\"document_答疑课堂（二）｜第二章rust进阶篇思考题答案.md\":\"rq96ZBKO\",\"document_结束语｜未来让rust带你“锈”到起飞.md\":\"CDoEtXUj\",\"document_结课测试｜来赴一场满分之约.md\":\"BDMdH3Zr\",\"index.md\":\"ZlsnMKnR\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh\",\"dir\":\"ltr\",\"title\":\"唐刚-Rust语言从入门到实战\",\"description\":\"Rust语言从入门到实战\",\"base\":\"/tanggang_rust/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/img/buding.svg\",\"siteTitle\":\"Rust语言从入门到实战\",\"outlineTitle\":\"⚡️文档内容大纲\",\"outline\":\"deep\",\"search\":{\"provider\":\"local\",\"options\":{\"locales\":{\"root\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"displayDetails\":\"显示详细信息\",\"resetButtonTitle\":\"清除查询条件\",\"backButtonTitle\":\"返回搜索结果\",\"footer\":{\"selectText\":\"选择\",\"selectKeyAriaLabel\":\"enter\",\"navigateText\":\"切换\",\"navigateUpKeyAriaLabel\":\"up arrow\",\"navigateDownKeyAriaLabel\":\"down arrow\",\"closeText\":\"关闭\",\"closeKeyAriaLabel\":\"escape\"}}}}},\"miniSearch\":{\"options\":{},\"searchOptions\":{}}}},\"sidebar\":{\"/\":[{\"text\":\"00｜开篇词｜拥抱Rust浪潮，迎接更极致的编程体验\",\"link\":\"/Document/00｜开篇词｜拥抱Rust浪潮，迎接更极致的编程体验\"},{\"text\":\"01｜快速入门：Rust中有哪些你不得不了解的基础语法？\",\"link\":\"/Document/01｜快速入门：Rust中有哪些你不得不了解的基础语法？\"},{\"text\":\"02｜所有权（上）：Rust是如何管理程序中的资源的？\",\"link\":\"/Document/02｜所有权（上）：Rust是如何管理程序中的资源的？\"},{\"text\":\"03｜所有权（下）：Rust中借用与引用的规则是怎样的？\",\"link\":\"/Document/03｜所有权（下）：Rust中借用与引用的规则是怎样的？\"},{\"text\":\"04｜字符串：对号入座，字符串其实没那么可怕！\",\"link\":\"/Document/04｜字符串：对号入座，字符串其实没那么可怕！\"},{\"text\":\"05｜复合类型（上）：结构体与面向对象特性\",\"link\":\"/Document/05｜复合类型（上）：结构体与面向对象特性\"},{\"text\":\"06｜复合类型（下）：枚举与模式匹配\",\"link\":\"/Document/06｜复合类型（下）：枚举与模式匹配\"},{\"text\":\"07｜类型与类型参数：给Rust小助手提供更多信息\",\"link\":\"/Document/07｜类型与类型参数：给Rust小助手提供更多信息\"},{\"text\":\"08｜Option-T-与Result-T,E-、迭代器\",\"link\":\"/Document/08｜Option-T-与Result-T,E-、迭代器\"},{\"text\":\"09｜初识trait：协议约束与能力配置\",\"link\":\"/Document/09｜初识trait：协议约束与能力配置\"},{\"text\":\"10｜再探trait：带类型参数的trait及traitobject\",\"link\":\"/Document/10｜再探trait：带类型参数的trait及traitobject\"},{\"text\":\"11｜常见trait解析：标准库中的常见trait应该怎么用？\",\"link\":\"/Document/11｜常见trait解析：标准库中的常见trait应该怎么用？\"},{\"text\":\"答疑课堂（一）｜第一章Rust基础篇思考题答案\",\"link\":\"/Document/答疑课堂（一）｜第一章Rust基础篇思考题答案\"},{\"text\":\"12｜智能指针：从所有权看智能指针\",\"link\":\"/Document/12｜智能指针：从所有权看智能指针\"},{\"text\":\"13｜独立王国：初步了解Rust异步并发编程\",\"link\":\"/Document/13｜独立王国：初步了解Rust异步并发编程\"},{\"text\":\"14｜tokio实战：编写一个网络命令行程序\",\"link\":\"/Document/14｜tokio实战：编写一个网络命令行程序\"},{\"text\":\"15｜tokio编程：在多任务之间操作同一片数据\",\"link\":\"/Document/15｜tokio编程：在多任务之间操作同一片数据\"},{\"text\":\"16｜tokio编程：使用channel在不同任务间通信？\",\"link\":\"/Document/16｜tokio编程：使用channel在不同任务间通信？\"},{\"text\":\"17｜tokio编程：Rust异步编程还有哪些需要注意的点？\",\"link\":\"/Document/17｜tokio编程：Rust异步编程还有哪些需要注意的点？\"},{\"text\":\"18｜错误处理系统：错误的构建、传递和处理\",\"link\":\"/Document/18｜错误处理系统：错误的构建、传递和处理\"},{\"text\":\"19｜Rust的宏体系：为自己的项目写一个简单的声明宏\",\"link\":\"/Document/19｜Rust的宏体系：为自己的项目写一个简单的声明宏\"},{\"text\":\"20｜生命周期：Rust如何做基本的生命周期符号标注？\",\"link\":\"/Document/20｜生命周期：Rust如何做基本的生命周期符号标注？\"},{\"text\":\"答疑课堂（二）｜第二章Rust进阶篇思考题答案\",\"link\":\"/Document/答疑课堂（二）｜第二章Rust进阶篇思考题答案\"},{\"text\":\"21｜Web开发（上）：如何使用Axum框架进行Web后端开发？\",\"link\":\"/Document/21｜Web开发（上）：如何使用Axum框架进行Web后端开发？\"},{\"text\":\"22｜Web开发（下）：如何实现一个TodoList应用？\",\"link\":\"/Document/22｜Web开发（下）：如何实现一个TodoList应用？\"},{\"text\":\"23｜Rust与大模型：用Candle做一个聊天机器人\",\"link\":\"/Document/23｜Rust与大模型：用Candle做一个聊天机器人\"},{\"text\":\"24｜Rust图像识别：利用YOLOv8识别对象\",\"link\":\"/Document/24｜Rust图像识别：利用YOLOv8识别对象\"},{\"text\":\"25｜RustGUI编程：用Slint为Chatbot实现一个界面\",\"link\":\"/Document/25｜RustGUI编程：用Slint为Chatbot实现一个界面\"},{\"text\":\"26｜RustGUI编程：用Slint为YOLOv8实现一个界面\",\"link\":\"/Document/26｜RustGUI编程：用Slint为YOLOv8实现一个界面\"},{\"text\":\"27｜RustBevy游戏开发：用300行代码做一个贪吃蛇游戏\",\"link\":\"/Document/27｜RustBevy游戏开发：用300行代码做一个贪吃蛇游戏\"},{\"text\":\"28｜Nom：用Rust写一个Parser解析器\",\"link\":\"/Document/28｜Nom：用Rust写一个Parser解析器\"},{\"text\":\"29｜Unsafe编程（上）：UnsafeRust中那些被封印的能力\",\"link\":\"/Document/29｜Unsafe编程（上）：UnsafeRust中那些被封印的能力\"},{\"text\":\"30｜Unsafe编程（下）：使用Rust为Python写一个扩展\",\"link\":\"/Document/30｜Unsafe编程（下）：使用Rust为Python写一个扩展\"},{\"text\":\"答疑课堂（三）｜第三章Rust应用篇思考题答案\",\"link\":\"/Document/答疑课堂（三）｜第三章Rust应用篇思考题答案\"},{\"text\":\"结课测试｜来赴一场满分之约\",\"link\":\"/Document/结课测试｜来赴一场满分之约\"},{\"text\":\"结束语｜未来让Rust带你“锈”到起飞\",\"link\":\"/Document/结束语｜未来让Rust带你“锈”到起飞\"}]},\"editLink\":{\"pattern\":\"https://github.com/muyaCode/FrontEndLearnNotes/edit/main/docs/:path\",\"text\":\"在 GitHub 上编辑此页\"},\"lastUpdated\":{\"text\":\"上次更新：\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"medium\"}},\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"footer\":{\"message\":\"Released under the MIT License.\",\"copyright\":\"Copyright © 2025  MuYa\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>